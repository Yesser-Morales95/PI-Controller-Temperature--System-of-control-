CCS PCM C Compiler, Version 5.053, 5967               15-Dec-16 22:54

               Filename:   C:\Users\YESSER-M\Desktop\Project Temperatura PI\Project Temperatura PI - Getchar - 16F1459\Project Temperatura PI OSC EXT\Project Control PI.lst

               ROM used:   5071 words (62%)
                           Largest free fragment is 2048
               RAM used:   119 (12%) at main() level
                           176 (17%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 16

*
0000:  MOVLP  10
0001:  GOTO   000
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  03
0010:  MOVF   11,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  03
0014:  MOVF   12,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  03
0018:  MOVF   13,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  03
001C:  MOVF   14,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   043
0023:  CLRF   05
0024:  MOVLW  91
0025:  MOVWF  04
0026:  BTFSS  00.5
0027:  GOTO   02A
0028:  BTFSC  11.5
0029:  GOTO   045
002A:  MOVF   20,W
002B:  MOVWF  77
002C:  MOVF   21,W
002D:  MOVWF  78
002E:  MOVF   22,W
002F:  MOVWF  79
0030:  MOVF   23,W
0031:  MOVWF  7A
0032:  MOVF   24,W
0033:  MOVLB  03
0034:  MOVWF  11
0035:  MOVLB  00
0036:  MOVF   25,W
0037:  MOVLB  03
0038:  MOVWF  12
0039:  MOVLB  00
003A:  MOVF   26,W
003B:  MOVLB  03
003C:  MOVWF  13
003D:  MOVLB  00
003E:  MOVF   27,W
003F:  MOVLB  03
0040:  MOVWF  14
0041:  RETFIE
0042:  MOVLB  00
0043:  MOVLP  00
0044:  GOTO   0E9
0045:  MOVLP  00
0046:  GOTO   062
....................                //****************************************************** 
....................                //Project        : Diseño Control PI V3.0  
....................                //Purpose        : Regulacion de temperatura  
....................                //Auther         : YESSER MORALES  
....................                //Company        : UNI  
....................                //Hardware       : PIC16F1459 
....................                //DATE           : December, 6th 2016 
....................                //********************************************************** 
.................... #include <16f1459.h>       //Pic a utilizar. 
.................... //////////// Standard Header file for the PIC16F1459 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1459 
*
0003:  DATA 0C,00
*
0047:  BRW
0048:  RETLW  28
0049:  RETLW  0C
004A:  RETLW  01
004B:  RETLW  06
*
00AE:  CLRF   77
00AF:  CLRF   78
00B0:  MOVF   6C,W
00B1:  BCF    03.0
00B2:  BTFSC  6D.0
00B3:  ADDWF  77,F
00B4:  RRF    77,F
00B5:  RRF    78,F
00B6:  BTFSC  6D.1
00B7:  ADDWF  77,F
00B8:  RRF    77,F
00B9:  RRF    78,F
00BA:  BTFSC  6D.2
00BB:  ADDWF  77,F
00BC:  RRF    77,F
00BD:  RRF    78,F
00BE:  BTFSC  6D.3
00BF:  ADDWF  77,F
00C0:  RRF    77,F
00C1:  RRF    78,F
00C2:  BTFSC  6D.4
00C3:  ADDWF  77,F
00C4:  RRF    77,F
00C5:  RRF    78,F
00C6:  BTFSC  6D.5
00C7:  ADDWF  77,F
00C8:  RRF    77,F
00C9:  RRF    78,F
00CA:  BTFSC  6D.6
00CB:  ADDWF  77,F
00CC:  RRF    77,F
00CD:  RRF    78,F
00CE:  BTFSC  6D.7
00CF:  ADDWF  77,F
00D0:  RRF    77,F
00D1:  RRF    78,F
*
00E3:  DATA D4,32
00E4:  DATA 6D,38
00E5:  DATA BD,12
00E6:  DATA 33,17
00E7:  DATA 32,23
00E8:  DATA 00,00
*
0112:  DATA 8C,29
0113:  DATA 65,3A
0114:  DATA F0,37
0115:  DATA 69,37
0116:  DATA 74,00
0117:  DATA 8C,29
0118:  DATA 65,3A
0119:  DATA F0,37
011A:  DATA 69,37
011B:  DATA 74,10
011C:  DATA 56,1D
011D:  DATA A0,12
011E:  DATA 64,00
011F:  DATA C4,22
0120:  DATA C6,20
0121:  DATA 55,26
0122:  DATA 54,00
0123:  DATA 0C,23
0124:  DATA 61,3B
0125:  DATA 6F,39
0126:  DATA A0,34
0127:  DATA EE,33
0128:  DATA F2,32
0129:  DATA F3,32
012A:  DATA 20,00
012B:  DATA D4,34
012C:  DATA F0,37
012D:  DATA 20,32
012E:  DATA 65,10
012F:  DATA E3,37
0130:  DATA 6E,3A
0131:  DATA F2,37
0132:  DATA 6C,00
0133:  DATA D4,34
0134:  DATA F0,37
0135:  DATA 20,32
0136:  DATA 65,10
0137:  DATA E3,37
0138:  DATA 6E,3A
0139:  DATA F2,37
013A:  DATA EC,1F
013B:  DATA 00,01
013C:  DATA 8C,21
013D:  DATA 6F,37
013E:  DATA 74,39
013F:  DATA 6F,36
0140:  DATA 20,28
0141:  DATA 49,10
0142:  DATA 00,01
0143:  DATA 49,37
0144:  DATA 67,39
0145:  DATA E5,39
0146:  DATA 65,10
0147:  DATA D3,32
0148:  DATA 74,10
0149:  DATA D0,37
014A:  DATA 69,37
014B:  DATA 74,00
014C:  DATA D3,32
014D:  DATA 74,10
014E:  DATA D0,37
014F:  DATA 69,37
0150:  DATA F4,1F
0151:  DATA 00,01
0152:  DATA 8C,29
0153:  DATA 65,3A
0154:  DATA F0,37
0155:  DATA 69,37
0156:  DATA 74,10
0157:  DATA 56,1D
0158:  DATA A0,12
0159:  DATA 64,00
015A:  DATA C3,37
015B:  DATA 6E,3A
015C:  DATA F2,37
015D:  DATA 6C,10
015E:  DATA D0,24
015F:  DATA 00,01
0160:  DATA 8C,21
0161:  DATA 6F,37
0162:  DATA 74,39
0163:  DATA 6F,36
0164:  DATA 20,28
0165:  DATA 49,22
0166:  DATA 20,00
0167:  DATA 49,37
0168:  DATA 67,39
0169:  DATA E5,39
016A:  DATA 65,10
016B:  DATA D3,32
016C:  DATA 74,10
016D:  DATA D0,37
016E:  DATA 69,37
016F:  DATA 74,00
0170:  DATA 8C,29
0171:  DATA 65,3A
0172:  DATA F0,37
0173:  DATA 69,37
0174:  DATA 74,10
0175:  DATA 56,10
0176:  DATA 25,32
0177:  DATA 00,01
0178:  BTFSC  03.1
0179:  GOTO   17E
017A:  MOVLW  20
017B:  MOVWF  05
017C:  MOVLW  8C
017D:  MOVWF  04
017E:  CLRF   77
017F:  CLRF   78
0180:  CLRF   79
0181:  CLRF   7A
0182:  MOVLB  01
0183:  CLRF   5C
0184:  CLRF   5D
0185:  CLRF   5E
0186:  CLRF   5F
0187:  MOVF   57,W
0188:  IORWF  56,W
0189:  IORWF  55,W
018A:  IORWF  54,W
018B:  BTFSC  03.2
018C:  GOTO   1BD
018D:  MOVLW  20
018E:  MOVWF  60
018F:  BCF    03.0
0190:  RLF    50,F
0191:  RLF    51,F
0192:  RLF    52,F
0193:  RLF    53,F
0194:  RLF    5C,F
0195:  RLF    5D,F
0196:  RLF    5E,F
0197:  RLF    5F,F
0198:  MOVF   57,W
0199:  SUBWF  5F,W
019A:  BTFSS  03.2
019B:  GOTO   1A6
019C:  MOVF   56,W
019D:  SUBWF  5E,W
019E:  BTFSS  03.2
019F:  GOTO   1A6
01A0:  MOVF   55,W
01A1:  SUBWF  5D,W
01A2:  BTFSS  03.2
01A3:  GOTO   1A6
01A4:  MOVF   54,W
01A5:  SUBWF  5C,W
01A6:  BTFSS  03.0
01A7:  GOTO   1B7
01A8:  MOVF   54,W
01A9:  SUBWF  5C,F
01AA:  MOVF   55,W
01AB:  BTFSS  03.0
01AC:  INCFSZ 55,W
01AD:  SUBWF  5D,F
01AE:  MOVF   56,W
01AF:  BTFSS  03.0
01B0:  INCFSZ 56,W
01B1:  SUBWF  5E,F
01B2:  MOVF   57,W
01B3:  BTFSS  03.0
01B4:  INCFSZ 57,W
01B5:  SUBWF  5F,F
01B6:  BSF    03.0
01B7:  RLF    77,F
01B8:  RLF    78,F
01B9:  RLF    79,F
01BA:  RLF    7A,F
01BB:  DECFSZ 60,F
01BC:  GOTO   18F
01BD:  MOVF   5C,W
01BE:  MOVWF  00
01BF:  MOVF   5D,W
01C0:  MOVWI  W,[FSR0+01]
01C1:  MOVF   5E,W
01C2:  MOVWI  W,[FSR0+02]
01C3:  MOVF   5F,W
01C4:  MOVWI  W,[FSR0+03]
01C5:  MOVLB  00
01C6:  RETURN
*
033A:  MOVF   0B,W
033B:  BCF    0B.7
033C:  MOVLB  03
033D:  BSF    15.7
033E:  BSF    15.0
033F:  NOP
0340:  NOP
0341:  BTFSC  09.7
0342:  BSF    0B.7
0343:  MOVF   13,W
0344:  ANDLW  7F
0345:  BTFSC  03.2
0346:  GOTO   386
0347:  MOVLB  01
0348:  MOVWF  3D
0349:  MOVLB  03
034A:  MOVF   11,W
034B:  MOVLB  01
034C:  MOVWF  3E
034D:  MOVLB  03
034E:  MOVF   12,W
034F:  MOVLB  01
0350:  MOVWF  3F
0351:  MOVF   3D,W
0352:  MOVWF  50
0353:  MOVLB  00
0354:  CALL   304
0355:  MOVLB  01
0356:  MOVF   3E,W
0357:  MOVLB  03
0358:  MOVWF  11
0359:  MOVLB  01
035A:  MOVF   3F,W
035B:  MOVLB  03
035C:  MOVWF  12
035D:  MOVF   0B,W
035E:  BCF    0B.7
035F:  BSF    15.7
0360:  BSF    15.0
0361:  NOP
0362:  NOP
0363:  BTFSC  09.7
0364:  BSF    0B.7
0365:  RLF    13,W
0366:  RLF    14,W
0367:  ANDLW  7F
0368:  BTFSC  03.2
0369:  GOTO   386
036A:  MOVLB  01
036B:  MOVWF  3D
036C:  MOVLB  03
036D:  MOVF   11,W
036E:  MOVLB  01
036F:  MOVWF  3E
0370:  MOVLB  03
0371:  MOVF   12,W
0372:  MOVLB  01
0373:  MOVWF  3F
0374:  MOVF   3D,W
0375:  MOVWF  50
0376:  MOVLB  00
0377:  CALL   304
0378:  MOVLB  01
0379:  MOVF   3E,W
037A:  MOVLB  03
037B:  MOVWF  11
037C:  MOVLB  01
037D:  MOVF   3F,W
037E:  MOVLB  03
037F:  MOVWF  12
0380:  INCF   11,F
0381:  BTFSC  03.2
0382:  INCF   12,F
0383:  MOVLB  00
0384:  GOTO   33A
0385:  MOVLB  03
0386:  MOVLB  00
0387:  RETURN
0388:  MOVLW  8E
0389:  MOVWF  77
038A:  MOVLB  01
038B:  MOVF   4A,W
038C:  MOVWF  78
038D:  MOVF   49,W
038E:  MOVWF  79
038F:  CLRF   7A
0390:  MOVF   78,F
0391:  BTFSS  03.2
0392:  GOTO   39D
0393:  MOVF   79,W
0394:  MOVWF  78
0395:  CLRF   79
0396:  MOVLW  08
0397:  SUBWF  77,F
0398:  MOVF   78,F
0399:  BTFSS  03.2
039A:  GOTO   39D
039B:  CLRF   77
039C:  GOTO   3A5
039D:  BCF    03.0
039E:  BTFSC  78.7
039F:  GOTO   3A4
03A0:  RLF    79,F
03A1:  RLF    78,F
03A2:  DECF   77,F
03A3:  GOTO   39D
03A4:  BCF    78.7
03A5:  MOVLB  00
03A6:  RETURN
03A7:  MOVLB  01
03A8:  MOVF   50,W
03A9:  BTFSC  03.2
03AA:  GOTO   418
03AB:  MOVWF  5C
03AC:  MOVF   54,W
03AD:  BTFSC  03.2
03AE:  GOTO   418
03AF:  ADDWF  5C,F
03B0:  BTFSC  03.0
03B1:  GOTO   3B9
03B2:  MOVLW  7F
03B3:  SUBWF  5C,F
03B4:  BTFSS  03.0
03B5:  GOTO   418
03B6:  BTFSC  03.2
03B7:  GOTO   418
03B8:  GOTO   3BD
03B9:  MOVLW  81
03BA:  ADDWF  5C,F
03BB:  BTFSC  03.0
03BC:  GOTO   418
03BD:  MOVF   5C,W
03BE:  MOVWF  77
03BF:  CLRF   78
03C0:  CLRF   79
03C1:  CLRF   7A
03C2:  MOVF   51,W
03C3:  MOVWF  60
03C4:  BSF    60.7
03C5:  MOVF   52,W
03C6:  MOVWF  5F
03C7:  MOVF   53,W
03C8:  MOVWF  5E
03C9:  MOVLW  18
03CA:  MOVWF  5C
03CB:  CLRF   5D
03CC:  BTFSS  5E.0
03CD:  GOTO   3E6
03CE:  MOVF   57,W
03CF:  ADDWF  7A,F
03D0:  BTFSS  03.0
03D1:  GOTO   3D8
03D2:  INCF   79,F
03D3:  BTFSS  03.2
03D4:  GOTO   3D8
03D5:  INCF   78,F
03D6:  BTFSC  03.2
03D7:  BSF    5D.7
03D8:  MOVF   56,W
03D9:  ADDWF  79,F
03DA:  BTFSS  03.0
03DB:  GOTO   3DF
03DC:  INCF   78,F
03DD:  BTFSC  03.2
03DE:  BSF    5D.7
03DF:  MOVF   55,W
03E0:  MOVWF  52
03E1:  BSF    52.7
03E2:  MOVF   52,W
03E3:  ADDWF  78,F
03E4:  BTFSC  03.0
03E5:  BSF    5D.7
03E6:  RLF    5D,F
03E7:  RRF    78,F
03E8:  RRF    79,F
03E9:  RRF    7A,F
03EA:  RRF    60,F
03EB:  RRF    5F,F
03EC:  RRF    5E,F
03ED:  BCF    03.0
03EE:  DECFSZ 5C,F
03EF:  GOTO   3CB
03F0:  MOVLW  01
03F1:  ADDWF  77,F
03F2:  BTFSC  03.0
03F3:  GOTO   418
03F4:  BTFSC  78.7
03F5:  GOTO   3FD
03F6:  RLF    60,F
03F7:  RLF    7A,F
03F8:  RLF    79,F
03F9:  RLF    78,F
03FA:  DECF   77,F
03FB:  BTFSC  03.2
03FC:  GOTO   418
03FD:  BTFSS  60.7
03FE:  GOTO   40E
03FF:  INCF   7A,F
0400:  BTFSS  03.2
0401:  GOTO   40E
0402:  INCF   79,F
0403:  BTFSS  03.2
0404:  GOTO   40E
0405:  INCF   78,F
0406:  BTFSS  03.2
0407:  GOTO   40E
0408:  RRF    78,F
0409:  RRF    79,F
040A:  RRF    7A,F
040B:  INCF   77,F
040C:  BTFSC  03.2
040D:  GOTO   418
040E:  MOVF   51,W
040F:  MOVWF  5D
0410:  MOVF   55,W
0411:  XORWF  5D,F
0412:  BTFSS  5D.7
0413:  GOTO   416
0414:  BSF    78.7
0415:  GOTO   41C
0416:  BCF    78.7
0417:  GOTO   41C
0418:  CLRF   77
0419:  CLRF   78
041A:  CLRF   79
041B:  CLRF   7A
041C:  MOVLB  00
041D:  RETURN
*
046A:  MOVLB  01
046B:  MOVF   50,W
046C:  SUBLW  B6
046D:  MOVWF  50
046E:  CLRF   7A
046F:  MOVF   51,W
0470:  MOVWF  54
0471:  BSF    51.7
0472:  BCF    03.0
0473:  RRF    51,F
0474:  RRF    52,F
0475:  RRF    53,F
0476:  RRF    7A,F
0477:  RRF    79,F
0478:  RRF    78,F
0479:  RRF    77,F
047A:  DECFSZ 50,F
047B:  GOTO   472
047C:  BTFSS  54.7
047D:  GOTO   489
047E:  COMF   77,F
047F:  COMF   78,F
0480:  COMF   79,F
0481:  COMF   7A,F
0482:  INCF   77,F
0483:  BTFSC  03.2
0484:  INCF   78,F
0485:  BTFSC  03.2
0486:  INCF   79,F
0487:  BTFSC  03.2
0488:  INCF   7A,F
0489:  MOVLB  00
048A:  RETURN
048B:  MOVF   04,W
048C:  MOVLB  01
048D:  MOVWF  48
048E:  MOVF   41,W
048F:  MOVWF  4A
0490:  BTFSC  03.2
0491:  GOTO   4AD
0492:  MOVF   40,W
0493:  MOVWF  53
0494:  MOVF   3F,W
0495:  MOVWF  52
0496:  MOVF   3E,W
0497:  MOVWF  51
0498:  MOVF   3D,W
0499:  MOVWF  50
049A:  CLRF   57
049B:  CLRF   56
049C:  MOVLW  20
049D:  MOVWF  55
049E:  MOVLW  82
049F:  MOVWF  54
04A0:  MOVLB  00
04A1:  CALL   3A7
04A2:  MOVF   7A,W
04A3:  MOVLB  01
04A4:  MOVWF  40
04A5:  MOVF   79,W
04A6:  MOVWF  3F
04A7:  MOVF   78,W
04A8:  MOVWF  3E
04A9:  MOVF   77,W
04AA:  MOVWF  3D
04AB:  DECFSZ 4A,F
04AC:  GOTO   492
04AD:  MOVF   40,W
04AE:  MOVWF  53
04AF:  MOVF   3F,W
04B0:  MOVWF  52
04B1:  MOVF   3E,W
04B2:  MOVWF  51
04B3:  MOVF   3D,W
04B4:  MOVWF  50
04B5:  MOVLB  00
04B6:  CALL   46A
04B7:  MOVF   7A,W
04B8:  MOVLB  01
04B9:  MOVWF  40
04BA:  MOVF   79,W
04BB:  MOVWF  3F
04BC:  MOVF   78,W
04BD:  MOVWF  3E
04BE:  MOVF   77,W
04BF:  MOVWF  3D
04C0:  BTFSS  40.7
04C1:  GOTO   4CF
04C2:  DECF   48,F
04C3:  BSF    48.5
04C4:  COMF   3D,F
04C5:  COMF   3E,F
04C6:  COMF   3F,F
04C7:  COMF   40,F
04C8:  INCF   3D,F
04C9:  BTFSC  03.2
04CA:  INCF   3E,F
04CB:  BTFSC  03.2
04CC:  INCF   3F,F
04CD:  BTFSC  03.2
04CE:  INCF   40,F
04CF:  MOVLW  3B
04D0:  MOVWF  4F
04D1:  MOVLW  9A
04D2:  MOVWF  4E
04D3:  MOVLW  CA
04D4:  MOVWF  4D
04D5:  CLRF   4C
04D6:  MOVLW  0A
04D7:  MOVWF  4A
04D8:  MOVF   41,W
04D9:  BTFSC  03.2
04DA:  INCF   48,F
04DB:  BSF    03.1
04DC:  MOVLW  20
04DD:  MOVWF  05
04DE:  MOVLW  6D
04DF:  MOVWF  04
04E0:  MOVF   40,W
04E1:  MOVWF  53
04E2:  MOVF   3F,W
04E3:  MOVWF  52
04E4:  MOVF   3E,W
04E5:  MOVWF  51
04E6:  MOVF   3D,W
04E7:  MOVWF  50
04E8:  MOVF   4F,W
04E9:  MOVWF  57
04EA:  MOVF   4E,W
04EB:  MOVWF  56
04EC:  MOVF   4D,W
04ED:  MOVWF  55
04EE:  MOVF   4C,W
04EF:  MOVWF  54
04F0:  MOVLB  00
04F1:  CALL   178
04F2:  MOVF   78,W
04F3:  MOVF   77,F
04F4:  BTFSS  03.2
04F5:  GOTO   50D
04F6:  MOVLB  01
04F7:  INCF   41,W
04F8:  SUBWF  4A,W
04F9:  BTFSS  03.2
04FA:  GOTO   4FD
04FB:  MOVLB  00
04FC:  GOTO   50D
04FD:  MOVF   48,W
04FE:  BTFSC  03.2
04FF:  GOTO   510
0500:  ANDLW  0F
0501:  SUBWF  4A,W
0502:  BTFSC  03.2
0503:  GOTO   506
0504:  BTFSC  03.0
0505:  GOTO   548
0506:  BTFSC  48.7
0507:  GOTO   548
0508:  BTFSC  48.6
0509:  GOTO   510
050A:  MOVLW  20
050B:  GOTO   542
050C:  MOVLB  00
050D:  MOVLW  20
050E:  MOVLB  01
050F:  ANDWF  48,F
0510:  BTFSS  48.5
0511:  GOTO   520
0512:  BCF    48.5
0513:  MOVF   41,W
0514:  BTFSS  03.2
0515:  DECF   48,F
0516:  MOVF   77,W
0517:  MOVWF  48
0518:  MOVLW  2D
0519:  MOVWF  50
051A:  MOVLB  00
051B:  CALL   304
051C:  MOVLB  01
051D:  MOVF   48,W
051E:  MOVWF  77
051F:  CLRF   48
0520:  MOVF   41,W
0521:  SUBWF  4A,W
0522:  BTFSS  03.2
0523:  GOTO   530
0524:  MOVF   77,W
0525:  MOVWF  48
0526:  MOVLW  2E
0527:  MOVWF  50
0528:  MOVLB  00
0529:  CALL   304
052A:  MOVLB  01
052B:  MOVF   48,W
052C:  MOVWF  77
052D:  MOVLW  20
052E:  ANDWF  48,F
052F:  MOVLW  00
0530:  MOVLW  30
0531:  BTFSS  48.5
0532:  GOTO   542
0533:  BCF    48.5
0534:  MOVF   41,W
0535:  BTFSS  03.2
0536:  DECF   48,F
0537:  MOVF   77,W
0538:  MOVWF  48
0539:  MOVLW  2D
053A:  MOVWF  50
053B:  MOVLB  00
053C:  CALL   304
053D:  MOVLB  01
053E:  MOVF   48,W
053F:  MOVWF  77
0540:  CLRF   48
0541:  MOVLW  30
0542:  ADDWF  77,F
0543:  MOVF   77,W
0544:  MOVWF  50
0545:  MOVLB  00
0546:  CALL   304
0547:  MOVLB  01
0548:  BCF    03.1
0549:  MOVF   4F,W
054A:  MOVWF  53
054B:  MOVF   4E,W
054C:  MOVWF  52
054D:  MOVF   4D,W
054E:  MOVWF  51
054F:  MOVF   4C,W
0550:  MOVWF  50
0551:  CLRF   57
0552:  CLRF   56
0553:  CLRF   55
0554:  MOVLW  0A
0555:  MOVWF  54
0556:  MOVLB  00
0557:  CALL   178
0558:  MOVF   7A,W
0559:  MOVLB  01
055A:  MOVWF  4F
055B:  MOVF   79,W
055C:  MOVWF  4E
055D:  MOVF   78,W
055E:  MOVWF  4D
055F:  MOVF   77,W
0560:  MOVWF  4C
0561:  DECFSZ 4A,F
0562:  GOTO   4DB
0563:  MOVLB  00
0564:  RETURN
0565:  MOVLW  80
0566:  BTFSS  03.1
0567:  GOTO   56B
0568:  MOVLB  01
0569:  XORWF  52,F
056A:  MOVLB  00
056B:  MOVLB  01
056C:  CLRF   5A
056D:  CLRF   5B
056E:  MOVF   4E,W
056F:  MOVWF  59
0570:  MOVF   52,W
0571:  XORWF  59,F
0572:  MOVF   4D,W
0573:  BTFSC  03.2
0574:  GOTO   65C
0575:  MOVWF  58
0576:  MOVWF  77
0577:  MOVF   51,W
0578:  BTFSC  03.2
0579:  GOTO   665
057A:  SUBWF  58,F
057B:  BTFSC  03.2
057C:  GOTO   600
057D:  BTFSS  03.0
057E:  GOTO   5BD
057F:  MOVF   52,W
0580:  MOVWF  5E
0581:  BSF    5E.7
0582:  MOVF   53,W
0583:  MOVWF  5D
0584:  MOVF   54,W
0585:  MOVWF  5C
0586:  CLRF   5B
0587:  BCF    03.0
0588:  RRF    5E,F
0589:  RRF    5D,F
058A:  RRF    5C,F
058B:  RRF    5B,F
058C:  DECFSZ 58,F
058D:  GOTO   586
058E:  BTFSS  59.7
058F:  GOTO   593
0590:  BSF    5A.0
0591:  GOTO   679
0592:  BCF    5A.0
0593:  BCF    58.0
0594:  BSF    5A.4
0595:  MOVLW  20
0596:  MOVWF  05
0597:  MOVLW  80
0598:  MOVWF  04
0599:  GOTO   68E
059A:  BCF    5A.4
059B:  BTFSC  59.7
059C:  GOTO   5A7
059D:  BTFSS  58.0
059E:  GOTO   5B2
059F:  RRF    5E,F
05A0:  RRF    5D,F
05A1:  RRF    5C,F
05A2:  RRF    5B,F
05A3:  INCF   77,F
05A4:  BTFSC  03.2
05A5:  GOTO   674
05A6:  GOTO   5B2
05A7:  BTFSC  5E.7
05A8:  GOTO   5B5
05A9:  BCF    03.0
05AA:  RLF    5B,F
05AB:  RLF    5C,F
05AC:  RLF    5D,F
05AD:  RLF    5E,F
05AE:  DECF   77,F
05AF:  BTFSC  03.2
05B0:  GOTO   674
05B1:  GOTO   5A7
05B2:  BSF    5A.6
05B3:  GOTO   621
05B4:  BCF    5A.6
05B5:  MOVF   4E,W
05B6:  MOVWF  59
05B7:  BTFSS  59.7
05B8:  GOTO   5BB
05B9:  BSF    5E.7
05BA:  GOTO   66D
05BB:  BCF    5E.7
05BC:  GOTO   66D
05BD:  MOVF   51,W
05BE:  MOVWF  58
05BF:  MOVWF  77
05C0:  MOVF   4D,W
05C1:  SUBWF  58,F
05C2:  MOVF   4E,W
05C3:  MOVWF  5E
05C4:  BSF    5E.7
05C5:  MOVF   4F,W
05C6:  MOVWF  5D
05C7:  MOVF   50,W
05C8:  MOVWF  5C
05C9:  CLRF   5B
05CA:  BCF    03.0
05CB:  RRF    5E,F
05CC:  RRF    5D,F
05CD:  RRF    5C,F
05CE:  RRF    5B,F
05CF:  DECFSZ 58,F
05D0:  GOTO   5C9
05D1:  BTFSS  59.7
05D2:  GOTO   5D6
05D3:  BSF    5A.1
05D4:  GOTO   679
05D5:  BCF    5A.1
05D6:  BCF    58.0
05D7:  BSF    5A.5
05D8:  MOVLW  20
05D9:  MOVWF  05
05DA:  MOVLW  84
05DB:  MOVWF  04
05DC:  GOTO   68E
05DD:  BCF    5A.5
05DE:  BTFSC  59.7
05DF:  GOTO   5EA
05E0:  BTFSS  58.0
05E1:  GOTO   5F5
05E2:  RRF    5E,F
05E3:  RRF    5D,F
05E4:  RRF    5C,F
05E5:  RRF    5B,F
05E6:  INCF   77,F
05E7:  BTFSC  03.2
05E8:  GOTO   674
05E9:  GOTO   5F5
05EA:  BTFSC  5E.7
05EB:  GOTO   5F8
05EC:  BCF    03.0
05ED:  RLF    5B,F
05EE:  RLF    5C,F
05EF:  RLF    5D,F
05F0:  RLF    5E,F
05F1:  DECF   77,F
05F2:  BTFSC  03.2
05F3:  GOTO   674
05F4:  GOTO   5EA
05F5:  BSF    5A.7
05F6:  GOTO   621
05F7:  BCF    5A.7
05F8:  MOVF   52,W
05F9:  MOVWF  59
05FA:  BTFSS  59.7
05FB:  GOTO   5FE
05FC:  BSF    5E.7
05FD:  GOTO   66D
05FE:  BCF    5E.7
05FF:  GOTO   66D
0600:  MOVF   52,W
0601:  MOVWF  5E
0602:  BSF    5E.7
0603:  MOVF   53,W
0604:  MOVWF  5D
0605:  MOVF   54,W
0606:  MOVWF  5C
0607:  BTFSS  59.7
0608:  GOTO   60D
0609:  BCF    5E.7
060A:  BSF    5A.2
060B:  GOTO   679
060C:  BCF    5A.2
060D:  CLRF   5B
060E:  BCF    58.0
060F:  MOVLW  20
0610:  MOVWF  05
0611:  MOVLW  80
0612:  MOVWF  04
0613:  GOTO   68E
0614:  BTFSC  59.7
0615:  GOTO   637
0616:  MOVF   4E,W
0617:  MOVWF  59
0618:  BTFSS  58.0
0619:  GOTO   621
061A:  RRF    5E,F
061B:  RRF    5D,F
061C:  RRF    5C,F
061D:  RRF    5B,F
061E:  INCF   77,F
061F:  BTFSC  03.2
0620:  GOTO   674
0621:  BTFSS  5B.7
0622:  GOTO   632
0623:  INCF   5C,F
0624:  BTFSS  03.2
0625:  GOTO   632
0626:  INCF   5D,F
0627:  BTFSS  03.2
0628:  GOTO   632
0629:  INCF   5E,F
062A:  BTFSS  03.2
062B:  GOTO   632
062C:  RRF    5E,F
062D:  RRF    5D,F
062E:  RRF    5C,F
062F:  INCF   77,F
0630:  BTFSC  03.2
0631:  GOTO   674
0632:  BTFSC  5A.6
0633:  GOTO   5B4
0634:  BTFSC  5A.7
0635:  GOTO   5F7
0636:  GOTO   656
0637:  MOVLW  80
0638:  XORWF  5E,F
0639:  BTFSS  5E.7
063A:  GOTO   63F
063B:  GOTO   679
063C:  MOVF   52,W
063D:  MOVWF  59
063E:  GOTO   64C
063F:  MOVF   4E,W
0640:  MOVWF  59
0641:  MOVF   5E,F
0642:  BTFSS  03.2
0643:  GOTO   64C
0644:  MOVF   5D,F
0645:  BTFSS  03.2
0646:  GOTO   64C
0647:  MOVF   5C,F
0648:  BTFSS  03.2
0649:  GOTO   64C
064A:  CLRF   77
064B:  GOTO   66D
064C:  BTFSC  5E.7
064D:  GOTO   656
064E:  BCF    03.0
064F:  RLF    5B,F
0650:  RLF    5C,F
0651:  RLF    5D,F
0652:  RLF    5E,F
0653:  DECFSZ 77,F
0654:  GOTO   64C
0655:  GOTO   674
0656:  BTFSS  59.7
0657:  GOTO   65A
0658:  BSF    5E.7
0659:  GOTO   66D
065A:  BCF    5E.7
065B:  GOTO   66D
065C:  MOVF   51,W
065D:  MOVWF  77
065E:  MOVF   52,W
065F:  MOVWF  5E
0660:  MOVF   53,W
0661:  MOVWF  5D
0662:  MOVF   54,W
0663:  MOVWF  5C
0664:  GOTO   66D
0665:  MOVF   4D,W
0666:  MOVWF  77
0667:  MOVF   4E,W
0668:  MOVWF  5E
0669:  MOVF   4F,W
066A:  MOVWF  5D
066B:  MOVF   50,W
066C:  MOVWF  5C
066D:  MOVF   5E,W
066E:  MOVWF  78
066F:  MOVF   5D,W
0670:  MOVWF  79
0671:  MOVF   5C,W
0672:  MOVWF  7A
0673:  GOTO   6AA
0674:  CLRF   77
0675:  CLRF   78
0676:  CLRF   79
0677:  CLRF   7A
0678:  GOTO   6AA
0679:  CLRF   5B
067A:  COMF   5C,F
067B:  COMF   5D,F
067C:  COMF   5E,F
067D:  COMF   5B,F
067E:  INCF   5B,F
067F:  BTFSS  03.2
0680:  GOTO   687
0681:  INCF   5C,F
0682:  BTFSS  03.2
0683:  GOTO   687
0684:  INCF   5D,F
0685:  BTFSC  03.2
0686:  INCF   5E,F
0687:  BTFSC  5A.0
0688:  GOTO   592
0689:  BTFSC  5A.1
068A:  GOTO   5D5
068B:  BTFSC  5A.2
068C:  GOTO   60C
068D:  GOTO   63C
068E:  MOVF   00,W
068F:  ADDWF  5C,F
0690:  BTFSS  03.0
0691:  GOTO   698
0692:  INCF   5D,F
0693:  BTFSS  03.2
0694:  GOTO   698
0695:  INCF   5E,F
0696:  BTFSC  03.2
0697:  BSF    58.0
0698:  MOVIW  [--FSR0],W
0699:  ADDWF  5D,F
069A:  BTFSS  03.0
069B:  GOTO   69F
069C:  INCF   5E,F
069D:  BTFSC  03.2
069E:  BSF    58.0
069F:  MOVIW  [--FSR0],W
06A0:  BTFSS  00.7
06A1:  XORLW  80
06A2:  ADDWF  5E,F
06A3:  BTFSC  03.0
06A4:  BSF    58.0
06A5:  BTFSC  5A.4
06A6:  GOTO   59A
06A7:  BTFSC  5A.5
06A8:  GOTO   5DD
06A9:  GOTO   614
06AA:  MOVLB  00
06AB:  RETURN
06AC:  MOVLB  01
06AD:  MOVF   4A,W
06AE:  MOVWF  52
06AF:  MOVF   4E,W
06B0:  XORWF  52,F
06B1:  BTFSS  52.7
06B2:  GOTO   6B8
06B3:  BCF    03.2
06B4:  BCF    03.0
06B5:  BTFSC  4A.7
06B6:  BSF    03.0
06B7:  GOTO   6EB
06B8:  MOVF   4A,W
06B9:  MOVWF  52
06BA:  MOVF   4D,W
06BB:  MOVWF  53
06BC:  MOVF   49,W
06BD:  SUBWF  53,F
06BE:  BTFSC  03.2
06BF:  GOTO   6C6
06C0:  BTFSS  52.7
06C1:  GOTO   6EB
06C2:  MOVF   03,W
06C3:  XORLW  01
06C4:  MOVWF  03
06C5:  GOTO   6EB
06C6:  MOVF   4E,W
06C7:  MOVWF  53
06C8:  MOVF   4A,W
06C9:  SUBWF  53,F
06CA:  BTFSC  03.2
06CB:  GOTO   6D2
06CC:  BTFSS  52.7
06CD:  GOTO   6EB
06CE:  MOVF   03,W
06CF:  XORLW  01
06D0:  MOVWF  03
06D1:  GOTO   6EB
06D2:  MOVF   4F,W
06D3:  MOVWF  53
06D4:  MOVF   4B,W
06D5:  SUBWF  53,F
06D6:  BTFSC  03.2
06D7:  GOTO   6DE
06D8:  BTFSS  52.7
06D9:  GOTO   6EB
06DA:  MOVF   03,W
06DB:  XORLW  01
06DC:  MOVWF  03
06DD:  GOTO   6EB
06DE:  MOVF   50,W
06DF:  MOVWF  53
06E0:  MOVF   4C,W
06E1:  SUBWF  53,F
06E2:  BTFSC  03.2
06E3:  GOTO   6EA
06E4:  BTFSS  52.7
06E5:  GOTO   6EB
06E6:  MOVF   03,W
06E7:  XORLW  01
06E8:  MOVWF  03
06E9:  GOTO   6EB
06EA:  BCF    03.0
06EB:  MOVLB  00
06EC:  RETURN
06ED:  MOVLW  8E
06EE:  MOVWF  77
06EF:  MOVLB  01
06F0:  MOVF   49,W
06F1:  SUBWF  77,F
06F2:  MOVF   4A,W
06F3:  MOVWF  79
06F4:  MOVF   4B,W
06F5:  MOVWF  78
06F6:  BSF    79.7
06F7:  MOVF   77,F
06F8:  BTFSC  03.2
06F9:  GOTO   705
06FA:  BCF    03.0
06FB:  MOVF   79,F
06FC:  BTFSS  03.2
06FD:  GOTO   701
06FE:  MOVF   78,F
06FF:  BTFSC  03.2
0700:  GOTO   705
0701:  RRF    79,F
0702:  RRF    78,F
0703:  DECFSZ 77,F
0704:  GOTO   6FA
0705:  BTFSS  4A.7
0706:  GOTO   70C
0707:  COMF   78,F
0708:  COMF   79,F
0709:  INCF   78,F
070A:  BTFSC  03.2
070B:  INCF   79,F
070C:  MOVLB  00
070D:  RETURN
070E:  MOVF   0B,W
070F:  BCF    0B.7
0710:  MOVLB  03
0711:  BSF    15.7
0712:  BSF    15.0
0713:  NOP
0714:  NOP
0715:  BTFSC  09.7
0716:  BSF    0B.7
0717:  BTFSC  03.0
0718:  GOTO   741
0719:  MOVF   13,W
071A:  ANDLW  7F
071B:  MOVLB  01
071C:  MOVWF  40
071D:  MOVLB  03
071E:  MOVF   11,W
071F:  MOVLB  01
0720:  MOVWF  41
0721:  MOVLB  03
0722:  MOVF   12,W
0723:  MOVLB  01
0724:  MOVWF  42
0725:  MOVF   40,W
0726:  MOVWF  50
0727:  MOVLB  00
0728:  CALL   304
0729:  MOVLB  01
072A:  MOVF   41,W
072B:  MOVLB  03
072C:  MOVWF  11
072D:  MOVLB  01
072E:  MOVF   42,W
072F:  MOVLB  03
0730:  MOVWF  12
0731:  MOVF   0B,W
0732:  BCF    0B.7
0733:  BSF    15.7
0734:  BSF    15.0
0735:  NOP
0736:  NOP
0737:  BTFSC  09.7
0738:  BSF    0B.7
0739:  MOVLB  01
073A:  DECFSZ 3D,F
073B:  GOTO   73D
073C:  GOTO   73F
073D:  MOVLB  03
073E:  GOTO   741
073F:  GOTO   764
0740:  MOVLB  03
0741:  RLF    13,W
0742:  RLF    14,W
0743:  ANDLW  7F
0744:  MOVLB  01
0745:  MOVWF  40
0746:  MOVLB  03
0747:  MOVF   11,W
0748:  MOVLB  01
0749:  MOVWF  41
074A:  MOVLB  03
074B:  MOVF   12,W
074C:  MOVLB  01
074D:  MOVWF  42
074E:  MOVF   40,W
074F:  MOVWF  50
0750:  MOVLB  00
0751:  CALL   304
0752:  MOVLB  01
0753:  MOVF   41,W
0754:  MOVLB  03
0755:  MOVWF  11
0756:  MOVLB  01
0757:  MOVF   42,W
0758:  MOVLB  03
0759:  MOVWF  12
075A:  INCF   11,F
075B:  BTFSC  03.2
075C:  INCF   12,F
075D:  BCF    03.0
075E:  MOVLB  01
075F:  DECFSZ 3D,F
0760:  GOTO   762
0761:  GOTO   764
0762:  MOVLB  00
0763:  GOTO   70E
0764:  MOVLB  00
0765:  RETURN
0766:  MOVLB  01
0767:  MOVF   45,W
0768:  CLRF   78
0769:  SUBWF  44,W
076A:  BTFSC  03.0
076B:  GOTO   76F
076C:  MOVF   44,W
076D:  MOVWF  77
076E:  GOTO   77B
076F:  CLRF   77
0770:  MOVLW  08
0771:  MOVWF  46
0772:  RLF    44,F
0773:  RLF    77,F
0774:  MOVF   45,W
0775:  SUBWF  77,W
0776:  BTFSC  03.0
0777:  MOVWF  77
0778:  RLF    78,F
0779:  DECFSZ 46,F
077A:  GOTO   772
077B:  MOVLB  00
077C:  RETURN
077D:  MOVLW  20
077E:  MOVLB  01
077F:  BTFSS  3E.4
0780:  MOVLW  30
0781:  MOVWF  40
0782:  MOVF   3D,W
0783:  MOVWF  77
0784:  BTFSS  3D.7
0785:  GOTO   78E
0786:  COMF   77,F
0787:  INCF   77,F
0788:  MOVF   77,W
0789:  MOVWF  3D
078A:  MOVLW  2D
078B:  MOVWF  40
078C:  BSF    3E.7
078D:  BSF    3E.0
078E:  MOVF   3D,W
078F:  MOVWF  44
0790:  MOVLW  64
0791:  MOVWF  45
0792:  MOVLB  00
0793:  CALL   766
0794:  MOVF   77,W
0795:  MOVLB  01
0796:  MOVWF  3D
0797:  MOVLW  30
0798:  ADDWF  78,W
0799:  MOVWF  41
079A:  MOVF   3D,W
079B:  MOVWF  44
079C:  MOVLW  0A
079D:  MOVWF  45
079E:  MOVLB  00
079F:  CALL   766
07A0:  MOVLW  30
07A1:  ADDWF  77,W
07A2:  MOVLB  01
07A3:  MOVWF  43
07A4:  MOVLW  30
07A5:  ADDWF  78,W
07A6:  MOVWF  42
07A7:  MOVF   40,W
07A8:  MOVWF  77
07A9:  MOVLW  30
07AA:  SUBWF  41,W
07AB:  BTFSC  03.2
07AC:  GOTO   7B1
07AD:  BSF    3E.1
07AE:  BTFSC  3E.7
07AF:  BSF    3E.2
07B0:  GOTO   7C5
07B1:  MOVF   40,W
07B2:  MOVWF  41
07B3:  MOVLW  20
07B4:  MOVWF  40
07B5:  MOVLW  30
07B6:  SUBWF  42,W
07B7:  BTFSC  03.2
07B8:  GOTO   7BD
07B9:  BSF    3E.0
07BA:  BTFSC  3E.7
07BB:  BSF    3E.1
07BC:  GOTO   7C5
07BD:  BTFSS  03.2
07BE:  BSF    3E.0
07BF:  BTFSS  03.2
07C0:  GOTO   7C5
07C1:  MOVF   41,W
07C2:  MOVWF  42
07C3:  MOVLW  20
07C4:  MOVWF  41
07C5:  BTFSC  3E.2
07C6:  GOTO   7CC
07C7:  BTFSC  3E.1
07C8:  GOTO   7D1
07C9:  BTFSC  3E.0
07CA:  GOTO   7D6
07CB:  GOTO   7DB
07CC:  MOVF   40,W
07CD:  MOVWF  50
07CE:  MOVLB  00
07CF:  CALL   304
07D0:  MOVLB  01
07D1:  MOVF   41,W
07D2:  MOVWF  50
07D3:  MOVLB  00
07D4:  CALL   304
07D5:  MOVLB  01
07D6:  MOVF   42,W
07D7:  MOVWF  50
07D8:  MOVLB  00
07D9:  CALL   304
07DA:  MOVLB  01
07DB:  MOVF   43,W
07DC:  MOVWF  50
07DD:  MOVLB  00
07DE:  CALL   304
07DF:  RETURN
*
0800:  MOVF   05,W
0801:  MOVLB  01
0802:  MOVWF  45
0803:  MOVF   04,W
0804:  MOVWF  44
0805:  SWAPF  3E,W
0806:  IORLW  F0
0807:  MOVWF  40
0808:  ADDWF  40,F
0809:  ADDLW  E2
080A:  MOVWF  41
080B:  ADDLW  32
080C:  MOVWF  43
080D:  MOVF   3E,W
080E:  ANDLW  0F
080F:  ADDWF  41,F
0810:  ADDWF  41,F
0811:  ADDWF  43,F
0812:  ADDLW  E9
0813:  MOVWF  42
0814:  ADDWF  42,F
0815:  ADDWF  42,F
0816:  SWAPF  3D,W
0817:  ANDLW  0F
0818:  ADDWF  42,F
0819:  ADDWF  43,F
081A:  RLF    42,F
081B:  RLF    43,F
081C:  COMF   43,F
081D:  RLF    43,F
081E:  MOVF   3D,W
081F:  ANDLW  0F
0820:  ADDWF  43,F
0821:  RLF    40,F
0822:  MOVLW  07
0823:  MOVWF  3F
0824:  MOVLW  0A
0825:  ADDWF  43,F
0826:  DECF   42,F
0827:  BTFSS  03.0
0828:  GOTO   025
0829:  ADDWF  42,F
082A:  DECF   41,F
082B:  BTFSS  03.0
082C:  GOTO   029
082D:  ADDWF  41,F
082E:  DECF   40,F
082F:  BTFSS  03.0
0830:  GOTO   02D
0831:  ADDWF  40,F
0832:  DECF   3F,F
0833:  BTFSS  03.0
0834:  GOTO   031
0835:  MOVLW  20
0836:  MOVWF  05
0837:  MOVLW  6F
0838:  MOVWF  04
0839:  MOVLW  07
083A:  ANDWF  44,W
083B:  BCF    44.6
083C:  ADDWF  04,F
083D:  MOVLW  00
083E:  ADDWFC 05,F
083F:  MOVF   04,W
0840:  SUBLW  73
0841:  BTFSS  03.2
0842:  GOTO   047
0843:  MOVF   05,W
0844:  SUBLW  20
0845:  BTFSC  03.2
0846:  BSF    44.6
0847:  MOVF   00,W
0848:  MOVWF  77
0849:  BTFSS  03.2
084A:  GOTO   053
084B:  BTFSC  44.6
084C:  GOTO   053
084D:  BTFSC  44.4
084E:  GOTO   066
084F:  BTFSC  44.3
0850:  GOTO   053
0851:  MOVLW  20
0852:  GOTO   056
0853:  BSF    44.3
0854:  BCF    44.4
0855:  MOVLW  30
0856:  ADDWF  77,F
0857:  MOVF   05,W
0858:  MOVWF  3E
0859:  MOVF   04,W
085A:  MOVWF  3D
085B:  MOVF   77,W
085C:  MOVWF  50
085D:  MOVLP  00
085E:  MOVLB  00
085F:  CALL   304
0860:  MOVLP  08
0861:  MOVLB  01
0862:  MOVF   3E,W
0863:  MOVWF  05
0864:  MOVF   3D,W
0865:  MOVWF  04
0866:  ADDFSR 01,FSR0
0867:  BTFSS  44.6
0868:  GOTO   03F
0869:  MOVLB  00
086A:  RETURN
086B:  MOVF   04,W
086C:  MOVLB  01
086D:  MOVWF  48
086E:  MOVF   45,W
086F:  MOVWF  4A
0870:  BTFSC  03.2
0871:  GOTO   08F
0872:  MOVF   44,W
0873:  MOVWF  53
0874:  MOVF   43,W
0875:  MOVWF  52
0876:  MOVF   42,W
0877:  MOVWF  51
0878:  MOVF   41,W
0879:  MOVWF  50
087A:  CLRF   57
087B:  CLRF   56
087C:  MOVLW  20
087D:  MOVWF  55
087E:  MOVLW  82
087F:  MOVWF  54
0880:  MOVLP  00
0881:  MOVLB  00
0882:  CALL   3A7
0883:  MOVLP  08
0884:  MOVF   7A,W
0885:  MOVLB  01
0886:  MOVWF  44
0887:  MOVF   79,W
0888:  MOVWF  43
0889:  MOVF   78,W
088A:  MOVWF  42
088B:  MOVF   77,W
088C:  MOVWF  41
088D:  DECFSZ 4A,F
088E:  GOTO   072
088F:  MOVF   44,W
0890:  MOVWF  53
0891:  MOVF   43,W
0892:  MOVWF  52
0893:  MOVF   42,W
0894:  MOVWF  51
0895:  MOVF   41,W
0896:  MOVWF  50
0897:  MOVLP  00
0898:  MOVLB  00
0899:  CALL   46A
089A:  MOVLP  08
089B:  MOVF   7A,W
089C:  MOVLB  01
089D:  MOVWF  44
089E:  MOVF   79,W
089F:  MOVWF  43
08A0:  MOVF   78,W
08A1:  MOVWF  42
08A2:  MOVF   77,W
08A3:  MOVWF  41
08A4:  BTFSS  44.7
08A5:  GOTO   0B3
08A6:  DECF   48,F
08A7:  BSF    48.5
08A8:  COMF   41,F
08A9:  COMF   42,F
08AA:  COMF   43,F
08AB:  COMF   44,F
08AC:  INCF   41,F
08AD:  BTFSC  03.2
08AE:  INCF   42,F
08AF:  BTFSC  03.2
08B0:  INCF   43,F
08B1:  BTFSC  03.2
08B2:  INCF   44,F
08B3:  MOVLW  3B
08B4:  MOVWF  4F
08B5:  MOVLW  9A
08B6:  MOVWF  4E
08B7:  MOVLW  CA
08B8:  MOVWF  4D
08B9:  CLRF   4C
08BA:  MOVLW  0A
08BB:  MOVWF  4A
08BC:  MOVF   45,W
08BD:  BTFSC  03.2
08BE:  INCF   48,F
08BF:  BSF    03.1
08C0:  MOVLW  20
08C1:  MOVWF  05
08C2:  MOVLW  71
08C3:  MOVWF  04
08C4:  MOVF   44,W
08C5:  MOVWF  53
08C6:  MOVF   43,W
08C7:  MOVWF  52
08C8:  MOVF   42,W
08C9:  MOVWF  51
08CA:  MOVF   41,W
08CB:  MOVWF  50
08CC:  MOVF   4F,W
08CD:  MOVWF  57
08CE:  MOVF   4E,W
08CF:  MOVWF  56
08D0:  MOVF   4D,W
08D1:  MOVWF  55
08D2:  MOVF   4C,W
08D3:  MOVWF  54
08D4:  MOVLP  00
08D5:  MOVLB  00
08D6:  CALL   178
08D7:  MOVLP  08
08D8:  MOVF   78,W
08D9:  MOVF   77,F
08DA:  BTFSS  03.2
08DB:  GOTO   0F3
08DC:  MOVLB  01
08DD:  INCF   45,W
08DE:  SUBWF  4A,W
08DF:  BTFSS  03.2
08E0:  GOTO   0E3
08E1:  MOVLB  00
08E2:  GOTO   0F3
08E3:  MOVF   48,W
08E4:  BTFSC  03.2
08E5:  GOTO   0F6
08E6:  ANDLW  0F
08E7:  SUBWF  4A,W
08E8:  BTFSC  03.2
08E9:  GOTO   0EC
08EA:  BTFSC  03.0
08EB:  GOTO   136
08EC:  BTFSC  48.7
08ED:  GOTO   136
08EE:  BTFSC  48.6
08EF:  GOTO   0F6
08F0:  MOVLW  20
08F1:  GOTO   12E
08F2:  MOVLB  00
08F3:  MOVLW  20
08F4:  MOVLB  01
08F5:  ANDWF  48,F
08F6:  BTFSS  48.5
08F7:  GOTO   108
08F8:  BCF    48.5
08F9:  MOVF   45,W
08FA:  BTFSS  03.2
08FB:  DECF   48,F
08FC:  MOVF   77,W
08FD:  MOVWF  48
08FE:  MOVLW  2D
08FF:  MOVLB  00
0900:  BTFSS  11.4
0901:  GOTO   100
0902:  MOVLB  03
0903:  MOVWF  1A
0904:  MOVLB  01
0905:  MOVF   48,W
0906:  MOVWF  77
0907:  CLRF   48
0908:  MOVF   45,W
0909:  SUBWF  4A,W
090A:  BTFSS  03.2
090B:  GOTO   11A
090C:  MOVF   77,W
090D:  MOVWF  48
090E:  MOVLW  2E
090F:  MOVLB  00
0910:  BTFSS  11.4
0911:  GOTO   110
0912:  MOVLB  03
0913:  MOVWF  1A
0914:  MOVLB  01
0915:  MOVF   48,W
0916:  MOVWF  77
0917:  MOVLW  20
0918:  ANDWF  48,F
0919:  MOVLW  00
091A:  MOVLW  30
091B:  BTFSS  48.5
091C:  GOTO   12E
091D:  BCF    48.5
091E:  MOVF   45,W
091F:  BTFSS  03.2
0920:  DECF   48,F
0921:  MOVF   77,W
0922:  MOVWF  48
0923:  MOVLW  2D
0924:  MOVLB  00
0925:  BTFSS  11.4
0926:  GOTO   125
0927:  MOVLB  03
0928:  MOVWF  1A
0929:  MOVLB  01
092A:  MOVF   48,W
092B:  MOVWF  77
092C:  CLRF   48
092D:  MOVLW  30
092E:  ADDWF  77,F
092F:  MOVF   77,W
0930:  MOVLB  00
0931:  BTFSS  11.4
0932:  GOTO   131
0933:  MOVLB  03
0934:  MOVWF  1A
0935:  MOVLB  01
0936:  BCF    03.1
0937:  MOVF   4F,W
0938:  MOVWF  53
0939:  MOVF   4E,W
093A:  MOVWF  52
093B:  MOVF   4D,W
093C:  MOVWF  51
093D:  MOVF   4C,W
093E:  MOVWF  50
093F:  CLRF   57
0940:  CLRF   56
0941:  CLRF   55
0942:  MOVLW  0A
0943:  MOVWF  54
0944:  MOVLP  00
0945:  MOVLB  00
0946:  CALL   178
0947:  MOVLP  08
0948:  MOVF   7A,W
0949:  MOVLB  01
094A:  MOVWF  4F
094B:  MOVF   79,W
094C:  MOVWF  4E
094D:  MOVF   78,W
094E:  MOVWF  4D
094F:  MOVF   77,W
0950:  MOVWF  4C
0951:  DECFSZ 4A,F
0952:  GOTO   0BF
0953:  MOVLP  08
0954:  MOVLB  00
0955:  GOTO   1C4 (RETURN)
*
095F:  MOVF   0B,W
0960:  BCF    0B.7
0961:  MOVLB  03
0962:  BSF    15.7
0963:  BSF    15.0
0964:  NOP
0965:  NOP
0966:  BTFSC  09.7
0967:  BSF    0B.7
0968:  BTFSC  03.0
0969:  GOTO   194
096A:  MOVF   13,W
096B:  ANDLW  7F
096C:  MOVLB  01
096D:  MOVWF  43
096E:  MOVLB  03
096F:  MOVF   11,W
0970:  MOVLB  01
0971:  MOVWF  44
0972:  MOVLB  03
0973:  MOVF   12,W
0974:  MOVLB  01
0975:  MOVWF  45
0976:  MOVF   43,W
0977:  MOVLB  00
0978:  BTFSS  11.4
0979:  GOTO   178
097A:  MOVLB  03
097B:  MOVWF  1A
097C:  MOVLB  01
097D:  MOVF   44,W
097E:  MOVLB  03
097F:  MOVWF  11
0980:  MOVLB  01
0981:  MOVF   45,W
0982:  MOVLB  03
0983:  MOVWF  12
0984:  MOVF   0B,W
0985:  BCF    0B.7
0986:  BSF    15.7
0987:  BSF    15.0
0988:  NOP
0989:  NOP
098A:  BTFSC  09.7
098B:  BSF    0B.7
098C:  MOVLB  01
098D:  DECFSZ 41,F
098E:  GOTO   190
098F:  GOTO   192
0990:  MOVLB  03
0991:  GOTO   194
0992:  GOTO   1B6
0993:  MOVLB  03
0994:  RLF    13,W
0995:  RLF    14,W
0996:  ANDLW  7F
0997:  MOVLB  01
0998:  MOVWF  43
0999:  MOVLB  03
099A:  MOVF   11,W
099B:  MOVLB  01
099C:  MOVWF  44
099D:  MOVLB  03
099E:  MOVF   12,W
099F:  MOVLB  01
09A0:  MOVWF  45
09A1:  MOVF   43,W
09A2:  MOVLB  00
09A3:  BTFSS  11.4
09A4:  GOTO   1A3
09A5:  MOVLB  03
09A6:  MOVWF  1A
09A7:  MOVLB  01
09A8:  MOVF   44,W
09A9:  MOVLB  03
09AA:  MOVWF  11
09AB:  MOVLB  01
09AC:  MOVF   45,W
09AD:  MOVLB  03
09AE:  MOVWF  12
09AF:  INCF   11,F
09B0:  BTFSC  03.2
09B1:  INCF   12,F
09B2:  BCF    03.0
09B3:  MOVLB  01
09B4:  DECFSZ 41,F
09B5:  GOTO   15F
*
09D2:  MOVF   0B,W
09D3:  BCF    0B.7
09D4:  MOVLB  03
09D5:  BSF    15.7
09D6:  BSF    15.0
09D7:  NOP
09D8:  NOP
09D9:  BTFSC  09.7
09DA:  BSF    0B.7
09DB:  MOVF   13,W
09DC:  ANDLW  7F
09DD:  BTFSC  03.2
09DE:  GOTO   222
09DF:  MOVLB  01
09E0:  MOVWF  3D
09E1:  MOVLB  03
09E2:  MOVF   11,W
09E3:  MOVLB  01
09E4:  MOVWF  3E
09E5:  MOVLB  03
09E6:  MOVF   12,W
09E7:  MOVLB  01
09E8:  MOVWF  3F
09E9:  MOVF   3D,W
09EA:  MOVLB  00
09EB:  BTFSS  11.4
09EC:  GOTO   1EB
09ED:  MOVLB  03
09EE:  MOVWF  1A
09EF:  MOVLB  01
09F0:  MOVF   3E,W
09F1:  MOVLB  03
09F2:  MOVWF  11
09F3:  MOVLB  01
09F4:  MOVF   3F,W
09F5:  MOVLB  03
09F6:  MOVWF  12
09F7:  MOVF   0B,W
09F8:  BCF    0B.7
09F9:  BSF    15.7
09FA:  BSF    15.0
09FB:  NOP
09FC:  NOP
09FD:  BTFSC  09.7
09FE:  BSF    0B.7
09FF:  RLF    13,W
0A00:  RLF    14,W
0A01:  ANDLW  7F
0A02:  BTFSC  03.2
0A03:  GOTO   222
0A04:  MOVLB  01
0A05:  MOVWF  3D
0A06:  MOVLB  03
0A07:  MOVF   11,W
0A08:  MOVLB  01
0A09:  MOVWF  3E
0A0A:  MOVLB  03
0A0B:  MOVF   12,W
0A0C:  MOVLB  01
0A0D:  MOVWF  3F
0A0E:  MOVF   3D,W
0A0F:  MOVLB  00
0A10:  BTFSS  11.4
0A11:  GOTO   210
0A12:  MOVLB  03
0A13:  MOVWF  1A
0A14:  MOVLB  01
0A15:  MOVF   3E,W
0A16:  MOVLB  03
0A17:  MOVWF  11
0A18:  MOVLB  01
0A19:  MOVF   3F,W
0A1A:  MOVLB  03
0A1B:  MOVWF  12
0A1C:  INCF   11,F
0A1D:  BTFSC  03.2
0A1E:  INCF   12,F
0A1F:  MOVLB  00
0A20:  GOTO   1D2
0A21:  MOVLB  03
0A22:  MOVLB  00
0A23:  RETURN
*
17E8:  BSF    0A.0
17E9:  BSF    0A.1
17EA:  BSF    0A.2
17EB:  ADDWF  02,F
17EC:  GOTO   110
17ED:  GOTO   37F
17EE:  GOTO   3D8
17EF:  GOTO   425
17F0:  GOTO   694
17F1:  GOTO   6E2
....................  
.................... #list 
....................  
.................... #device adc=10             //Resolucion de ADC. 
.................... #FUSES NOWDT, HS, NOPUT,NOBROWNOUT,MCLR, NOLVP,INTRC_IO, NOPROTECT,NOPUT //Fuses de Configuracion del pic, Ejemplo INTRC_IO declara un reloj interno. 
.................... //#BYTE OSCCON = 0b00111000  //Ajuste del registro de reloj, en este caso ajustando a una Frecuencia de 8MHZ 
.................... #use delay (clock=4MHZ) //La funcion delay usara el reloj interno 
*
004C:  MOVLW  20
004D:  MOVWF  05
004E:  MOVLW  9C
004F:  MOVWF  04
0050:  MOVF   00,W
0051:  BTFSC  03.2
0052:  GOTO   061
0053:  MOVLW  01
0054:  MOVWF  78
0055:  CLRF   77
0056:  DECFSZ 77,F
0057:  GOTO   056
0058:  DECFSZ 78,F
0059:  GOTO   055
005A:  MOVLW  4A
005B:  MOVWF  77
005C:  DECFSZ 77,F
005D:  GOTO   05C
005E:  GOTO   05F
005F:  DECFSZ 00,F
0060:  GOTO   053
0061:  RETURN
.................... #include <math.h>          //Habilitacion de la libreria de Calculos matematicos 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <stdio.h> 
....................  
.................... //Declaracion de registros especiales sin necesidad de uso de funciones propias del Compilador 
.................... #BYTE PWM2CON=getenv("SFR:PWM2CON")  
.................... #BYTE PWM1CON=getenv("SFR:PWM1CON")  
....................  
.................... #include "flex_lcd.c"      //Llamada a la libreria con su propia configuracion Esta esta dentro de la carpeta de compilacion 
.................... // flex_lcd.c 
....................  
.................... // Change these pins to fit your own board. 
....................  
.................... #define LCD_DB4 PIN_B6 
.................... #define LCD_DB5 PIN_C7 
.................... #define LCD_DB6 PIN_C3 
.................... #define LCD_DB7 PIN_C4 
....................  
.................... #define LCD_E PIN_C1 
.................... //#define LCD_RW PIN_A3 
.................... #define LCD_RS  PIN_C0 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... //#define USE_LCD_RW 1 
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2 // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................   0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................   0xc, // Display on 
....................   1, // Clear display 
....................   6 // Increment cursor 
.................... }; 
....................  
....................  
.................... //------------------------------------- 
....................  
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
....................   // Note: !! converts an integer expression 
....................   // to a boolean (1 or 0). 
....................   output_bit(LCD_DB4, !!(nibble & 1)); 
*
0240:  MOVLB  01
0241:  BTFSC  58.0
0242:  GOTO   247
0243:  MOVLB  02
0244:  BCF    0D.6
0245:  GOTO   249
0246:  MOVLB  01
0247:  MOVLB  02
0248:  BSF    0D.6
0249:  MOVLB  01
024A:  BCF    0D.6
....................   output_bit(LCD_DB5, !!(nibble & 2)); 
024B:  BTFSC  58.1
024C:  GOTO   251
024D:  MOVLB  02
024E:  BCF    0E.7
024F:  GOTO   253
0250:  MOVLB  01
0251:  MOVLB  02
0252:  BSF    0E.7
0253:  MOVLB  01
0254:  BCF    0E.7
....................   output_bit(LCD_DB6, !!(nibble & 4)); 
0255:  BTFSC  58.2
0256:  GOTO   25B
0257:  MOVLB  02
0258:  BCF    0E.3
0259:  GOTO   25D
025A:  MOVLB  01
025B:  MOVLB  02
025C:  BSF    0E.3
025D:  MOVLB  01
025E:  BCF    0E.3
....................   output_bit(LCD_DB7, !!(nibble & 8)); 
025F:  BTFSC  58.3
0260:  GOTO   265
0261:  MOVLB  02
0262:  BCF    0E.4
0263:  GOTO   267
0264:  MOVLB  01
0265:  MOVLB  02
0266:  BSF    0E.4
0267:  MOVLB  01
0268:  BCF    0E.4
....................  
....................   delay_cycles(1); 
0269:  NOP
....................   output_high(LCD_E); 
026A:  BCF    0E.1
026B:  MOVLB  02
026C:  BSF    0E.1
....................   delay_cycles(2);// 2us 
026D:  GOTO   26E
....................   output_low(LCD_E); 
026E:  MOVLB  01
026F:  BCF    0E.1
0270:  MOVLB  02
0271:  BCF    0E.1
0272:  MOVLB  00
0273:  RETURN
.................... } 
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine. For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
....................   int8 retval; 
....................   // Create bit variables so that we can easily set 
....................   // individual bits in the retval variable. 
....................   #bit retval_0 = retval.0 
....................   #bit retval_1 = retval.1 
....................   #bit retval_2 = retval.2 
....................   #bit retval_3 = retval.3 
....................  
....................   retval = 0; 
....................  
....................   output_high(LCD_E); 
....................   delay_cycles(1); 
....................  
....................   retval_0 = input(LCD_DB4); 
....................   retval_1 = input(LCD_DB5); 
....................   retval_2 = input(LCD_DB6); 
....................   retval_3 = input(LCD_DB7); 
....................  
....................   output_low(LCD_E); 
....................  
....................   return(retval); 
.................... } 
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
....................   int8 low; 
....................   int8 high; 
....................  
....................   output_high(LCD_RW); 
....................   delay_cycles(1); 
....................  
....................   high = lcd_read_nibble(); 
....................  
....................   low = lcd_read_nibble(); 
....................  
....................   return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
....................  
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
....................   output_low(LCD_RS); 
0274:  MOVLB  01
0275:  BCF    0E.0
0276:  MOVLB  02
0277:  BCF    0E.0
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60); 
0278:  MOVLW  13
0279:  MOVWF  77
027A:  DECFSZ 77,F
027B:  GOTO   27A
027C:  GOTO   27D
.................... #endif 
....................  
....................   if(address) 
027D:  MOVLB  01
027E:  MOVF   55,F
027F:  BTFSC  03.2
0280:  GOTO   286
....................   output_high(LCD_RS); 
0281:  BCF    0E.0
0282:  MOVLB  02
0283:  BSF    0E.0
0284:  GOTO   289
0285:  MOVLB  01
....................   else 
....................   output_low(LCD_RS); 
0286:  BCF    0E.0
0287:  MOVLB  02
0288:  BCF    0E.0
....................  
....................   delay_cycles(1); 
0289:  NOP
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
....................   output_low(LCD_E); 
028A:  MOVLB  01
028B:  BCF    0E.1
028C:  MOVLB  02
028D:  BCF    0E.1
....................  
....................   lcd_send_nibble(n >> 4); 
028E:  MOVLB  01
028F:  SWAPF  56,W
0290:  MOVWF  57
0291:  MOVLW  0F
0292:  ANDWF  57,F
0293:  MOVF   57,W
0294:  MOVWF  58
0295:  MOVLB  00
0296:  CALL   240
....................   lcd_send_nibble(n & 0xf); 
0297:  MOVLB  01
0298:  MOVF   56,W
0299:  ANDLW  0F
029A:  MOVWF  57
029B:  MOVWF  58
029C:  MOVLB  00
029D:  CALL   240
029E:  RETURN
.................... } 
....................  
.................... //---------------------------- 
....................  
.................... void lcd_init(void) 
.................... { 
....................   int8 i; 
....................  
....................   output_low(LCD_RS); 
029F:  MOVLB  01
02A0:  BCF    0E.0
02A1:  MOVLB  02
02A2:  BCF    0E.0
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
....................   output_low(LCD_E); 
02A3:  MOVLB  01
02A4:  BCF    0E.1
02A5:  MOVLB  02
02A6:  BCF    0E.1
02A7:  MOVLB  00
02A8:  CLRF   28
02A9:  BTFSC  0B.7
02AA:  BSF    28.7
02AB:  BCF    0B.7
....................  
....................   delay_ms(15);//15ms 
02AC:  MOVLW  0F
02AD:  MOVLB  01
02AE:  MOVWF  6C
02AF:  MOVLB  00
02B0:  CALL   04C
02B1:  BTFSC  28.7
02B2:  BSF    0B.7
....................  
....................   for(i=0 ;i < 3; i++) 
02B3:  MOVLB  01
02B4:  CLRF   3D
02B5:  MOVF   3D,W
02B6:  SUBLW  02
02B7:  BTFSS  03.0
02B8:  GOTO   2CB
....................   { 
....................     lcd_send_nibble(0x03); 
02B9:  MOVLW  03
02BA:  MOVWF  58
02BB:  MOVLB  00
02BC:  CALL   240
02BD:  CLRF   28
02BE:  BTFSC  0B.7
02BF:  BSF    28.7
02C0:  BCF    0B.7
....................     delay_ms(5);//5ms 
02C1:  MOVLW  05
02C2:  MOVLB  01
02C3:  MOVWF  6C
02C4:  MOVLB  00
02C5:  CALL   04C
02C6:  BTFSC  28.7
02C7:  BSF    0B.7
02C8:  MOVLB  01
02C9:  INCF   3D,F
02CA:  GOTO   2B5
....................   } 
....................  
....................   lcd_send_nibble(0x02); 
02CB:  MOVLW  02
02CC:  MOVWF  58
02CD:  MOVLB  00
02CE:  CALL   240
....................  
....................   for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
02CF:  MOVLB  01
02D0:  CLRF   3D
02D1:  MOVF   3D,W
02D2:  SUBLW  03
02D3:  BTFSS  03.0
02D4:  GOTO   2ED
....................   { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
02D5:  MOVF   3D,W
02D6:  MOVLB  00
02D7:  CALL   047
02D8:  MOVLB  01
02D9:  MOVWF  3E
02DA:  CLRF   55
02DB:  MOVF   3E,W
02DC:  MOVWF  56
02DD:  MOVLB  00
02DE:  CALL   274
02DF:  CLRF   28
02E0:  BTFSC  0B.7
02E1:  BSF    28.7
02E2:  BCF    0B.7
....................  
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled. One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
.................... #ifndef USE_LCD_RW 
.................... delay_ms(5); 
02E3:  MOVLW  05
02E4:  MOVLB  01
02E5:  MOVWF  6C
02E6:  MOVLB  00
02E7:  CALL   04C
02E8:  BTFSC  28.7
02E9:  BSF    0B.7
.................... #endif 
02EA:  MOVLB  01
02EB:  INCF   3D,F
02EC:  GOTO   2D1
.................... } 
02ED:  MOVLP  10
02EE:  MOVLB  00
02EF:  GOTO   090 (RETURN)
....................  
.................... } 
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
....................   int8 address; 
....................  
....................   if(y != 1) 
02F0:  MOVLB  01
02F1:  DECFSZ 52,W
02F2:  GOTO   2F4
02F3:  GOTO   2F7
....................   address = lcd_line_two; 
02F4:  MOVLW  40
02F5:  MOVWF  53
02F6:  GOTO   2F8
....................   else 
....................   address=0; 
02F7:  CLRF   53
....................  
....................   address += x-1; 
02F8:  MOVLW  01
02F9:  SUBWF  51,W
02FA:  ADDWF  53,F
....................   lcd_send_byte(0, 0x80 | address); 
02FB:  MOVF   53,W
02FC:  IORLW  80
02FD:  MOVWF  54
02FE:  CLRF   55
02FF:  MOVF   54,W
0300:  MOVWF  56
0301:  MOVLB  00
0302:  CALL   274
0303:  RETURN
.................... } 
....................  
.................... //----------------------------- 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................   switch(c) 
0304:  MOVLB  01
0305:  MOVF   50,W
0306:  XORLW  0C
0307:  MOVLB  00
0308:  BTFSC  03.2
0309:  GOTO   311
030A:  XORLW  06
030B:  BTFSC  03.2
030C:  GOTO   323
030D:  XORLW  02
030E:  BTFSC  03.2
030F:  GOTO   32B
0310:  GOTO   332
....................   { 
....................     case '\f': 
....................       lcd_send_byte(0,1); 
0311:  MOVLB  01
0312:  CLRF   55
0313:  MOVLW  01
0314:  MOVWF  56
0315:  MOVLB  00
0316:  CALL   274
0317:  CLRF   28
0318:  BTFSC  0B.7
0319:  BSF    28.7
031A:  BCF    0B.7
....................       delay_ms(2);//2ms 
031B:  MOVLW  02
031C:  MOVLB  01
031D:  MOVWF  6C
031E:  MOVLB  00
031F:  CALL   04C
0320:  BTFSC  28.7
0321:  BSF    0B.7
....................       break; 
0322:  GOTO   339
....................  
....................     case '\n': 
....................       lcd_gotoxy(1,2); 
0323:  MOVLW  01
0324:  MOVLB  01
0325:  MOVWF  51
0326:  MOVLW  02
0327:  MOVWF  52
0328:  MOVLB  00
0329:  CALL   2F0
....................       break; 
032A:  GOTO   339
....................  
....................     case '\b': 
....................       lcd_send_byte(0,0x10); 
032B:  MOVLB  01
032C:  CLRF   55
032D:  MOVLW  10
032E:  MOVWF  56
032F:  MOVLB  00
0330:  CALL   274
....................       break; 
0331:  GOTO   339
....................  
....................     default: 
....................       lcd_send_byte(1,c); 
0332:  MOVLW  01
0333:  MOVLB  01
0334:  MOVWF  55
0335:  MOVF   50,W
0336:  MOVWF  56
0337:  MOVLB  00
0338:  CALL   274
....................       break; 
....................   } 
0339:  RETURN
.................... } 
....................  
.................... void lcd_comand(int d) 
.................... { 
.................... lcd_send_byte(0,d); 
.................... } 
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
....................   char value; 
....................  
....................   lcd_gotoxy(x,y); 
....................  
....................   // Wait until busy flag is low. 
....................   while(bit_test(lcd_read_byte(),7)); 
....................  
....................   output_high(LCD_RS); 
....................   value = lcd_read_byte(); 
....................   output_low(lcd_RS); 
....................  
....................   return(value); 
.................... } 
.................... #endif 
....................  
.................... void lcd_setcursor_vb(short visible, short blink) { 
....................   lcd_send_byte(0, 0xC|(visible<<1)|blink); 
.................... } 
....................  
.................... #use rs232(baud=9600,BITS=8,PARITY=N, xmit=PIN_B7, rcv=PIN_B5, stream=HOSTPC,errors)  //Configuracion de comunicacion serial UART  
*
0074:  MOVLB  00
0075:  BTFSS  11.5
0076:  GOTO   075
0077:  MOVLB  03
0078:  MOVF   1D,W
0079:  MOVLB  00
007A:  MOVWF  2F
007B:  MOVLB  03
007C:  MOVF   19,W
007D:  MOVWF  78
007E:  MOVLB  00
007F:  BTFSS  2F.1
0080:  GOTO   085
0081:  MOVLB  03
0082:  BCF    1D.4
0083:  BSF    1D.4
0084:  MOVLB  00
*
00DA:  MOVLB  00
00DB:  BTFSS  11.4
00DC:  GOTO   0DB
00DD:  MOVLB  03
00DE:  MOVWF  1A
.................... #use pwm(PWM1, OUTPUT=PIN_C5, TIMER=2, FREQUENCY=1000, STREAM=P1)                      //Configuracion de PWM1 
*
01C7:  MOVLB  01
01C8:  MOVF   44,W
01C9:  MOVWF  53
01CA:  MOVF   43,W
01CB:  MOVWF  52
01CC:  MOVF   42,W
01CD:  MOVWF  51
01CE:  MOVF   41,W
01CF:  MOVWF  50
01D0:  MOVF   40,W
01D1:  MOVWF  57
01D2:  MOVF   3F,W
01D3:  MOVWF  56
01D4:  MOVF   3E,W
01D5:  MOVWF  55
01D6:  MOVF   3D,W
01D7:  MOVWF  54
01D8:  MOVLB  00
01D9:  CALL   178
01DA:  MOVF   79,W
01DB:  BTFSS  03.2
01DC:  GOTO   1E3
01DD:  MOVF   78,W
01DE:  BTFSS  03.2
01DF:  GOTO   1E3
01E0:  MOVF   77,W
01E1:  BTFSS  03.2
01E2:  GOTO   230
01E3:  MOVF   7A,W
01E4:  MOVLB  01
01E5:  MOVWF  53
01E6:  MOVF   79,W
01E7:  MOVWF  52
01E8:  MOVF   78,W
01E9:  MOVWF  51
01EA:  MOVF   77,W
01EB:  MOVWF  50
01EC:  CLRF   57
01ED:  CLRF   56
01EE:  CLRF   55
01EF:  MOVLW  04
01F0:  MOVWF  54
01F1:  MOVLB  00
01F2:  CALL   178
01F3:  MOVF   79,W
01F4:  BTFSS  03.2
01F5:  GOTO   1FC
01F6:  MOVF   78,W
01F7:  BTFSS  03.2
01F8:  GOTO   1FC
01F9:  MOVF   77,W
01FA:  BTFSS  03.2
01FB:  GOTO   233
01FC:  MOVF   7A,W
01FD:  MOVLB  01
01FE:  MOVWF  53
01FF:  MOVF   79,W
0200:  MOVWF  52
0201:  MOVF   78,W
0202:  MOVWF  51
0203:  MOVF   77,W
0204:  MOVWF  50
0205:  CLRF   57
0206:  CLRF   56
0207:  CLRF   55
0208:  MOVLW  04
0209:  MOVWF  54
020A:  MOVLB  00
020B:  CALL   178
020C:  MOVF   79,W
020D:  BTFSS  03.2
020E:  GOTO   215
020F:  MOVF   78,W
0210:  BTFSS  03.2
0211:  GOTO   215
0212:  MOVF   77,W
0213:  BTFSS  03.2
0214:  GOTO   236
0215:  MOVF   7A,W
0216:  MOVLB  01
0217:  MOVWF  53
0218:  MOVF   79,W
0219:  MOVWF  52
021A:  MOVF   78,W
021B:  MOVWF  51
021C:  MOVF   77,W
021D:  MOVWF  50
021E:  CLRF   57
021F:  CLRF   56
0220:  CLRF   55
0221:  MOVLW  04
0222:  MOVWF  54
0223:  MOVLB  00
0224:  CALL   178
0225:  MOVF   79,W
0226:  BTFSS  03.2
0227:  GOTO   22E
0228:  MOVF   78,W
0229:  BTFSS  03.2
022A:  GOTO   22E
022B:  MOVF   77,W
022C:  BTFSS  03.2
022D:  GOTO   239
022E:  CLRF   77
022F:  GOTO   239
0230:  MOVLW  04
0231:  MOVWF  1C
0232:  GOTO   23B
0233:  MOVLW  05
0234:  MOVWF  1C
0235:  GOTO   23B
0236:  MOVLW  06
0237:  MOVWF  1C
0238:  GOTO   23B
0239:  MOVLW  07
023A:  MOVWF  1C
023B:  DECF   77,F
023C:  MOVF   77,W
023D:  MOVWF  1B
023E:  MOVLP  10
023F:  GOTO   051 (RETURN)
....................  
.................... //Declaracion de Constantes 
....................  
.................... #define a 9.53 
.................... #define b 0.918 
.................... #define a1 13.74 
.................... #define b1 1.30 
.................... #define c 3.20 
.................... #define MA 1000.0 
.................... #define MI 0.0 
.................... #define LSB 0.004882  
....................  
.................... //Declaracion de Variables 
.................... unsigned int contRTCC=0; 
.................... float rtdv,rtdr; 
.................... float rkt,ekt,pkt,ukt,pkt_1=0.0,ekt_1=0.0; 
.................... float rktd,ektd,pktd,qktd,uktd,pktd_1=0.0,ektd_1=0.0; 
.................... int16 Controld,Dutyd; 
.................... int16 valor,Control,Duty; 
.................... float temp1,D,Dd; 
.................... int set_point=60; 
.................... int v1[2]; 
.................... int nb,i,flag; 
.................... char ch[2],g[1]; 
.................... enum {Esperando,Ajustando,EleccionPI,cPI,EleccionPID,cPID,envioDT}state; 
.................... //INTERRUPCION RDA RECEPCION DE DATOS SERIE 
.................... #int_RDA 
.................... void RDA_ISR(VOID) 
.................... { 
.................... //setup_wdt(WDT_ON); 
.................... ch[1]=0; 
*
0062:  MOVLB  01
0063:  CLRF   37
....................  
.................... for (i=0;i<2;i++) 
0064:  CLRF   71
0065:  MOVF   71,W
0066:  SUBLW  01
0067:  BTFSS  03.0
0068:  GOTO   0AA
.................... { 
.................... ch[i]=getch(); 
0069:  MOVLW  66
006A:  ADDWF  71,W
006B:  MOVWF  04
006C:  MOVLW  20
006D:  MOVWF  05
006E:  BTFSC  03.0
006F:  INCF   05,F
0070:  MOVF   05,W
0071:  MOVWF  6F
0072:  MOVF   04,W
0073:  MOVWF  6E
*
0085:  MOVLB  01
0086:  MOVF   6F,W
0087:  MOVWF  05
0088:  MOVF   6E,W
0089:  MOVWF  04
008A:  MOVF   78,W
008B:  MOVWF  00
....................  
.................... if(i==0){ 
008C:  MOVF   71,F
008D:  BTFSS  03.2
008E:  GOTO   09C
....................  
.................... delay_ms(1); 
008F:  MOVLW  01
0090:  MOVWF  6C
0091:  MOVLB  00
0092:  CALL   04C
.................... v1[0]=ch[0]-48; 
0093:  MOVLW  30
0094:  MOVLB  01
0095:  SUBWF  36,W
0096:  MOVWF  34
.................... delay_ms(100); 
0097:  MOVLW  64
0098:  MOVWF  6C
0099:  MOVLB  00
009A:  CALL   04C
009B:  MOVLB  01
.................... } 
.................... if(i==1){ 
009C:  DECFSZ 71,W
009D:  GOTO   0A8
.................... v1[1]=ch[1]-48; 
009E:  MOVLW  30
009F:  SUBWF  37,W
00A0:  MOVWF  35
.................... g[0]=ch[1]; 
00A1:  MOVF   37,W
00A2:  MOVWF  73
.................... delay_ms(100); 
00A3:  MOVLW  64
00A4:  MOVWF  6C
00A5:  MOVLB  00
00A6:  CALL   04C
00A7:  MOVLB  01
....................  
.................... } 
00A8:  INCF   71,F
00A9:  GOTO   065
.................... } 
....................            nb=((10*v1[0])+v1[1]); 
00AA:  MOVLW  0A
00AB:  MOVWF  6C
00AC:  MOVF   34,W
00AD:  MOVWF  6D
*
00D2:  MOVF   35,W
00D3:  ADDWF  78,W
00D4:  MOVWF  70
....................            Set_point=nb; 
00D5:  MOVF   70,W
00D6:  MOVLB  00
00D7:  MOVWF  6F
....................            
.................... putchar(ch[1]); 
00D8:  MOVLB  01
00D9:  MOVF   37,W
.................... //sleep(); 
....................  
*
00DF:  MOVLB  00
00E0:  BCF    11.5
00E1:  MOVLP  00
00E2:  GOTO   02A
.................... } 
....................  
....................  
....................  
.................... //ENVIO DE DATOS SERIE 
.................... void envioUART(float temp){ 
....................    //datoTX[0]=ADC >> 8;     //Asignacion de desplazamiento hacia la derecha                                             
....................   // datoTX[1]=ADC & 0xFF;   //Asignacion AND de Bits   
....................   // putc(datoTX[0]);            
....................   // putc(datoTX[1]);          //Envio de Datos  
....................   printf("Temp=%3.2F",temp); 
*
0956:  MOVLW  E3
0957:  MOVLB  03
0958:  MOVWF  11
0959:  MOVLW  00
095A:  MOVWF  12
095B:  BCF    03.0
095C:  MOVLW  05
095D:  MOVLB  01
095E:  MOVWF  41
*
09B6:  MOVLW  02
09B7:  MOVWF  04
09B8:  MOVF   40,W
09B9:  MOVWF  44
09BA:  MOVF   3F,W
09BB:  MOVWF  43
09BC:  MOVF   3E,W
09BD:  MOVWF  42
09BE:  MOVF   3D,W
09BF:  MOVWF  41
09C0:  MOVLW  02
09C1:  MOVWF  45
09C2:  MOVLB  00
09C3:  GOTO   06B
09C4:  CLRF   28
09C5:  BTFSC  0B.7
09C6:  BSF    28.7
09C7:  BCF    0B.7
....................   delay_ms(100); 
09C8:  MOVLW  64
09C9:  MOVLB  01
09CA:  MOVWF  6C
09CB:  MOVLP  00
09CC:  MOVLB  00
09CD:  CALL   04C
09CE:  MOVLP  08
09CF:  BTFSC  28.7
09D0:  BSF    0B.7
09D1:  RETURN
.................... } 
....................  
.................... //CALCULOS DE RTD 
.................... float calculos_rtd(int16 ADC) { 
....................                 float temp; 
.................... rtdv=(ADC*LSB);//46.10;                    /* Calculate volt LM35  */ 
*
041E:  MOVLB  01
041F:  MOVF   3E,W
0420:  MOVWF  4A
0421:  MOVF   3D,W
0422:  MOVWF  49
0423:  MOVLB  00
0424:  CALL   388
0425:  MOVF   7A,W
0426:  MOVLB  01
0427:  MOVWF  53
0428:  MOVF   79,W
0429:  MOVWF  52
042A:  MOVF   78,W
042B:  MOVWF  51
042C:  MOVF   77,W
042D:  MOVWF  50
042E:  MOVLW  2F
042F:  MOVWF  57
0430:  MOVLW  F9
0431:  MOVWF  56
0432:  MOVLW  1F
0433:  MOVWF  55
0434:  MOVLW  77
0435:  MOVWF  54
0436:  MOVLB  00
0437:  CALL   3A7
0438:  MOVF   7A,W
0439:  MOVWF  34
043A:  MOVF   79,W
043B:  MOVWF  33
043C:  MOVF   78,W
043D:  MOVWF  32
043E:  MOVF   77,W
043F:  MOVWF  31
....................                                                                                                    //!rtdr = (rtdv*10000.0)/(5.0-rtdv);          /* Calculate RTD resistance rtdr  */  
....................                                                                                                    //!y = (0.15274) - ((rtdr-100.0)*(2310.0e-7));   //CT1 CT2 55C 
....................                                                                                                    //!y = sqrt(y) ; 
....................                                                                                                    //!temp = (y-0.39083)/(-0.0001155); 
.................... temp=rtdv*100; 
0440:  MOVF   34,W
0441:  MOVLB  01
0442:  MOVWF  53
0443:  MOVLB  00
0444:  MOVF   33,W
0445:  MOVLB  01
0446:  MOVWF  52
0447:  MOVLB  00
0448:  MOVF   32,W
0449:  MOVLB  01
044A:  MOVWF  51
044B:  MOVLB  00
044C:  MOVF   31,W
044D:  MOVLB  01
044E:  MOVWF  50
044F:  CLRF   57
0450:  CLRF   56
0451:  MOVLW  48
0452:  MOVWF  55
0453:  MOVLW  85
0454:  MOVWF  54
0455:  MOVLB  00
0456:  CALL   3A7
0457:  MOVF   7A,W
0458:  MOVLB  01
0459:  MOVWF  42
045A:  MOVF   79,W
045B:  MOVWF  41
045C:  MOVF   78,W
045D:  MOVWF  40
045E:  MOVF   77,W
045F:  MOVWF  3F
....................     return temp; 
0460:  MOVF   3F,W
0461:  MOVWF  77
0462:  MOVF   40,W
0463:  MOVWF  78
0464:  MOVF   41,W
0465:  MOVWF  79
0466:  MOVF   42,W
0467:  MOVWF  7A
0468:  MOVLB  00
0469:  RETURN
.................... } 
....................  
.................... //CALCULOS DE PI 
.................... float calculos_pi(float &t, int &SP) { 
....................         float ct; 
.................... rkt=SP; 
*
113C:  CLRF   4A
113D:  MOVLB  00
113E:  MOVF   6F,W
113F:  MOVLB  01
1140:  MOVWF  49
1141:  MOVLP  00
1142:  MOVLB  00
1143:  CALL   388
1144:  MOVLP  10
1145:  MOVF   7A,W
1146:  MOVWF  3C
1147:  MOVF   79,W
1148:  MOVWF  3B
1149:  MOVF   78,W
114A:  MOVWF  3A
114B:  MOVF   77,W
114C:  MOVWF  39
*
1451:  CLRF   4A
1452:  MOVLB  00
1453:  MOVF   6F,W
1454:  MOVLB  01
1455:  MOVWF  49
1456:  MOVLP  00
1457:  MOVLB  00
1458:  CALL   388
1459:  MOVLP  10
145A:  MOVF   7A,W
145B:  MOVWF  3C
145C:  MOVF   79,W
145D:  MOVWF  3B
145E:  MOVF   78,W
145F:  MOVWF  3A
1460:  MOVF   77,W
1461:  MOVWF  39
....................  
....................   /* Calculate error */ 
....................   ekt=rkt-t; 
*
114D:  BSF    03.1
114E:  MOVF   3C,W
114F:  MOVLB  01
1150:  MOVWF  50
1151:  MOVLB  00
1152:  MOVF   3B,W
1153:  MOVLB  01
1154:  MOVWF  4F
1155:  MOVLB  00
1156:  MOVF   3A,W
1157:  MOVLB  01
1158:  MOVWF  4E
1159:  MOVLB  00
115A:  MOVF   39,W
115B:  MOVLB  01
115C:  MOVWF  4D
115D:  MOVF   2B,W
115E:  MOVWF  54
115F:  MOVF   2A,W
1160:  MOVWF  53
1161:  MOVF   29,W
1162:  MOVWF  52
1163:  MOVF   28,W
1164:  MOVWF  51
1165:  MOVLP  00
1166:  MOVLB  00
1167:  CALL   565
1168:  MOVLP  10
1169:  MOVF   7A,W
116A:  MOVWF  40
116B:  MOVF   79,W
116C:  MOVWF  3F
116D:  MOVF   78,W
116E:  MOVWF  3E
116F:  MOVF   77,W
1170:  MOVWF  3D
*
1462:  BSF    03.1
1463:  MOVF   3C,W
1464:  MOVLB  01
1465:  MOVWF  50
1466:  MOVLB  00
1467:  MOVF   3B,W
1468:  MOVLB  01
1469:  MOVWF  4F
146A:  MOVLB  00
146B:  MOVF   3A,W
146C:  MOVLB  01
146D:  MOVWF  4E
146E:  MOVLB  00
146F:  MOVF   39,W
1470:  MOVLB  01
1471:  MOVWF  4D
1472:  MOVF   2B,W
1473:  MOVWF  54
1474:  MOVF   2A,W
1475:  MOVWF  53
1476:  MOVF   29,W
1477:  MOVWF  52
1478:  MOVF   28,W
1479:  MOVWF  51
147A:  MOVLP  00
147B:  MOVLB  00
147C:  CALL   565
147D:  MOVLP  10
147E:  MOVF   7A,W
147F:  MOVWF  40
1480:  MOVF   79,W
1481:  MOVWF  3F
1482:  MOVF   78,W
1483:  MOVWF  3E
1484:  MOVF   77,W
1485:  MOVWF  3D
....................   /*end  Calculate error */ 
....................  
....................   /* Calculate I term */ 
....................   pkt=b*ekt+pkt_1; 
*
1171:  MOVLW  0C
1172:  MOVLB  01
1173:  MOVWF  53
1174:  MOVLW  02
1175:  MOVWF  52
1176:  MOVLW  6B
1177:  MOVWF  51
1178:  MOVLW  7E
1179:  MOVWF  50
117A:  MOVLB  00
117B:  MOVF   40,W
117C:  MOVLB  01
117D:  MOVWF  57
117E:  MOVLB  00
117F:  MOVF   3F,W
1180:  MOVLB  01
1181:  MOVWF  56
1182:  MOVLB  00
1183:  MOVF   3E,W
1184:  MOVLB  01
1185:  MOVWF  55
1186:  MOVLB  00
1187:  MOVF   3D,W
1188:  MOVLB  01
1189:  MOVWF  54
118A:  MOVLP  00
118B:  MOVLB  00
118C:  CALL   3A7
118D:  MOVLP  10
118E:  MOVF   7A,W
118F:  MOVLB  01
1190:  MOVWF  47
1191:  MOVF   79,W
1192:  MOVWF  46
1193:  MOVF   78,W
1194:  MOVWF  45
1195:  MOVF   77,W
1196:  MOVWF  44
1197:  BCF    03.1
1198:  MOVF   47,W
1199:  MOVWF  50
119A:  MOVF   46,W
119B:  MOVWF  4F
119C:  MOVF   45,W
119D:  MOVWF  4E
119E:  MOVF   44,W
119F:  MOVWF  4D
11A0:  MOVLB  00
11A1:  MOVF   4C,W
11A2:  MOVLB  01
11A3:  MOVWF  54
11A4:  MOVLB  00
11A5:  MOVF   4B,W
11A6:  MOVLB  01
11A7:  MOVWF  53
11A8:  MOVLB  00
11A9:  MOVF   4A,W
11AA:  MOVLB  01
11AB:  MOVWF  52
11AC:  MOVLB  00
11AD:  MOVF   49,W
11AE:  MOVLB  01
11AF:  MOVWF  51
11B0:  MOVLP  00
11B1:  MOVLB  00
11B2:  CALL   565
11B3:  MOVLP  10
11B4:  MOVF   7A,W
11B5:  MOVWF  44
11B6:  MOVF   79,W
11B7:  MOVWF  43
11B8:  MOVF   78,W
11B9:  MOVWF  42
11BA:  MOVF   77,W
11BB:  MOVWF  41
*
1486:  MOVLW  0C
1487:  MOVLB  01
1488:  MOVWF  53
1489:  MOVLW  02
148A:  MOVWF  52
148B:  MOVLW  6B
148C:  MOVWF  51
148D:  MOVLW  7E
148E:  MOVWF  50
148F:  MOVLB  00
1490:  MOVF   40,W
1491:  MOVLB  01
1492:  MOVWF  57
1493:  MOVLB  00
1494:  MOVF   3F,W
1495:  MOVLB  01
1496:  MOVWF  56
1497:  MOVLB  00
1498:  MOVF   3E,W
1499:  MOVLB  01
149A:  MOVWF  55
149B:  MOVLB  00
149C:  MOVF   3D,W
149D:  MOVLB  01
149E:  MOVWF  54
149F:  MOVLP  00
14A0:  MOVLB  00
14A1:  CALL   3A7
14A2:  MOVLP  10
14A3:  MOVF   7A,W
14A4:  MOVLB  01
14A5:  MOVWF  47
14A6:  MOVF   79,W
14A7:  MOVWF  46
14A8:  MOVF   78,W
14A9:  MOVWF  45
14AA:  MOVF   77,W
14AB:  MOVWF  44
14AC:  BCF    03.1
14AD:  MOVF   47,W
14AE:  MOVWF  50
14AF:  MOVF   46,W
14B0:  MOVWF  4F
14B1:  MOVF   45,W
14B2:  MOVWF  4E
14B3:  MOVF   44,W
14B4:  MOVWF  4D
14B5:  MOVLB  00
14B6:  MOVF   4C,W
14B7:  MOVLB  01
14B8:  MOVWF  54
14B9:  MOVLB  00
14BA:  MOVF   4B,W
14BB:  MOVLB  01
14BC:  MOVWF  53
14BD:  MOVLB  00
14BE:  MOVF   4A,W
14BF:  MOVLB  01
14C0:  MOVWF  52
14C1:  MOVLB  00
14C2:  MOVF   49,W
14C3:  MOVLB  01
14C4:  MOVWF  51
14C5:  MOVLP  00
14C6:  MOVLB  00
14C7:  CALL   565
14C8:  MOVLP  10
14C9:  MOVF   7A,W
14CA:  MOVWF  44
14CB:  MOVF   79,W
14CC:  MOVWF  43
14CD:  MOVF   78,W
14CE:  MOVWF  42
14CF:  MOVF   77,W
14D0:  MOVWF  41
....................   /*end  Calculate I term */ 
....................  
....................   /* Calculate PI output */ 
....................    ukt=pkt+a*ekt; 
*
11BC:  MOVLW  E1
11BD:  MOVLB  01
11BE:  MOVWF  53
11BF:  MOVLW  7A
11C0:  MOVWF  52
11C1:  MOVLW  18
11C2:  MOVWF  51
11C3:  MOVLW  82
11C4:  MOVWF  50
11C5:  MOVLB  00
11C6:  MOVF   40,W
11C7:  MOVLB  01
11C8:  MOVWF  57
11C9:  MOVLB  00
11CA:  MOVF   3F,W
11CB:  MOVLB  01
11CC:  MOVWF  56
11CD:  MOVLB  00
11CE:  MOVF   3E,W
11CF:  MOVLB  01
11D0:  MOVWF  55
11D1:  MOVLB  00
11D2:  MOVF   3D,W
11D3:  MOVLB  01
11D4:  MOVWF  54
11D5:  MOVLP  00
11D6:  MOVLB  00
11D7:  CALL   3A7
11D8:  MOVLP  10
11D9:  BCF    03.1
11DA:  MOVF   44,W
11DB:  MOVLB  01
11DC:  MOVWF  50
11DD:  MOVLB  00
11DE:  MOVF   43,W
11DF:  MOVLB  01
11E0:  MOVWF  4F
11E1:  MOVLB  00
11E2:  MOVF   42,W
11E3:  MOVLB  01
11E4:  MOVWF  4E
11E5:  MOVLB  00
11E6:  MOVF   41,W
11E7:  MOVLB  01
11E8:  MOVWF  4D
11E9:  MOVF   7A,W
11EA:  MOVWF  54
11EB:  MOVF   79,W
11EC:  MOVWF  53
11ED:  MOVF   78,W
11EE:  MOVWF  52
11EF:  MOVF   77,W
11F0:  MOVWF  51
11F1:  MOVLP  00
11F2:  MOVLB  00
11F3:  CALL   565
11F4:  MOVLP  10
11F5:  MOVF   7A,W
11F6:  MOVWF  48
11F7:  MOVF   79,W
11F8:  MOVWF  47
11F9:  MOVF   78,W
11FA:  MOVWF  46
11FB:  MOVF   77,W
11FC:  MOVWF  45
*
14D1:  MOVLW  E1
14D2:  MOVLB  01
14D3:  MOVWF  53
14D4:  MOVLW  7A
14D5:  MOVWF  52
14D6:  MOVLW  18
14D7:  MOVWF  51
14D8:  MOVLW  82
14D9:  MOVWF  50
14DA:  MOVLB  00
14DB:  MOVF   40,W
14DC:  MOVLB  01
14DD:  MOVWF  57
14DE:  MOVLB  00
14DF:  MOVF   3F,W
14E0:  MOVLB  01
14E1:  MOVWF  56
14E2:  MOVLB  00
14E3:  MOVF   3E,W
14E4:  MOVLB  01
14E5:  MOVWF  55
14E6:  MOVLB  00
14E7:  MOVF   3D,W
14E8:  MOVLB  01
14E9:  MOVWF  54
14EA:  MOVLP  00
14EB:  MOVLB  00
14EC:  CALL   3A7
14ED:  MOVLP  10
14EE:  BCF    03.1
14EF:  MOVF   44,W
14F0:  MOVLB  01
14F1:  MOVWF  50
14F2:  MOVLB  00
14F3:  MOVF   43,W
14F4:  MOVLB  01
14F5:  MOVWF  4F
14F6:  MOVLB  00
14F7:  MOVF   42,W
14F8:  MOVLB  01
14F9:  MOVWF  4E
14FA:  MOVLB  00
14FB:  MOVF   41,W
14FC:  MOVLB  01
14FD:  MOVWF  4D
14FE:  MOVF   7A,W
14FF:  MOVWF  54
1500:  MOVF   79,W
1501:  MOVWF  53
1502:  MOVF   78,W
1503:  MOVWF  52
1504:  MOVF   77,W
1505:  MOVWF  51
1506:  MOVLP  00
1507:  MOVLB  00
1508:  CALL   565
1509:  MOVLP  10
150A:  MOVF   7A,W
150B:  MOVWF  48
150C:  MOVF   79,W
150D:  MOVWF  47
150E:  MOVF   78,W
150F:  MOVWF  46
1510:  MOVF   77,W
1511:  MOVWF  45
....................   /*end Calculate PI output */ 
....................  
....................   if(ukt > MA) { 
*
11FD:  MOVLB  01
11FE:  CLRF   4C
11FF:  CLRF   4B
1200:  MOVLW  7A
1201:  MOVWF  4A
1202:  MOVLW  88
1203:  MOVWF  49
1204:  MOVLB  00
1205:  MOVF   48,W
1206:  MOVLB  01
1207:  MOVWF  50
1208:  MOVLB  00
1209:  MOVF   47,W
120A:  MOVLB  01
120B:  MOVWF  4F
120C:  MOVLB  00
120D:  MOVF   46,W
120E:  MOVLB  01
120F:  MOVWF  4E
1210:  MOVLB  00
1211:  MOVF   45,W
1212:  MOVLB  01
1213:  MOVWF  4D
1214:  MOVLP  00
1215:  MOVLB  00
1216:  CALL   6AC
1217:  MOVLP  10
1218:  BTFSS  03.0
1219:  GOTO   229
*
1512:  MOVLB  01
1513:  CLRF   4C
1514:  CLRF   4B
1515:  MOVLW  7A
1516:  MOVWF  4A
1517:  MOVLW  88
1518:  MOVWF  49
1519:  MOVLB  00
151A:  MOVF   48,W
151B:  MOVLB  01
151C:  MOVWF  50
151D:  MOVLB  00
151E:  MOVF   47,W
151F:  MOVLB  01
1520:  MOVWF  4F
1521:  MOVLB  00
1522:  MOVF   46,W
1523:  MOVLB  01
1524:  MOVWF  4E
1525:  MOVLB  00
1526:  MOVF   45,W
1527:  MOVLB  01
1528:  MOVWF  4D
1529:  MOVLP  00
152A:  MOVLB  00
152B:  CALL   6AC
152C:  MOVLP  10
152D:  BTFSS  03.0
152E:  GOTO   53E
....................   pkt=pkt_1; 
*
121A:  MOVF   4C,W
121B:  MOVWF  44
121C:  MOVF   4B,W
121D:  MOVWF  43
121E:  MOVF   4A,W
121F:  MOVWF  42
1220:  MOVF   49,W
1221:  MOVWF  41
*
152F:  MOVF   4C,W
1530:  MOVWF  44
1531:  MOVF   4B,W
1532:  MOVWF  43
1533:  MOVF   4A,W
1534:  MOVWF  42
1535:  MOVF   49,W
1536:  MOVWF  41
....................   ukt =MA;     } 
*
1222:  CLRF   48
1223:  CLRF   47
1224:  MOVLW  7A
1225:  MOVWF  46
1226:  MOVLW  88
1227:  MOVWF  45
1228:  GOTO   24E
*
1537:  CLRF   48
1538:  CLRF   47
1539:  MOVLW  7A
153A:  MOVWF  46
153B:  MOVLW  88
153C:  MOVWF  45
153D:  GOTO   563
....................   else if(ukt < MI) 
*
1229:  MOVF   48,W
122A:  MOVLB  01
122B:  MOVWF  4C
122C:  MOVLB  00
122D:  MOVF   47,W
122E:  MOVLB  01
122F:  MOVWF  4B
1230:  MOVLB  00
1231:  MOVF   46,W
1232:  MOVLB  01
1233:  MOVWF  4A
1234:  MOVLB  00
1235:  MOVF   45,W
1236:  MOVLB  01
1237:  MOVWF  49
1238:  CLRF   50
1239:  CLRF   4F
123A:  CLRF   4E
123B:  CLRF   4D
123C:  MOVLP  00
123D:  MOVLB  00
123E:  CALL   6AC
123F:  MOVLP  10
1240:  BTFSS  03.0
1241:  GOTO   24E
*
153E:  MOVF   48,W
153F:  MOVLB  01
1540:  MOVWF  4C
1541:  MOVLB  00
1542:  MOVF   47,W
1543:  MOVLB  01
1544:  MOVWF  4B
1545:  MOVLB  00
1546:  MOVF   46,W
1547:  MOVLB  01
1548:  MOVWF  4A
1549:  MOVLB  00
154A:  MOVF   45,W
154B:  MOVLB  01
154C:  MOVWF  49
154D:  CLRF   50
154E:  CLRF   4F
154F:  CLRF   4E
1550:  CLRF   4D
1551:  MOVLP  00
1552:  MOVLB  00
1553:  CALL   6AC
1554:  MOVLP  10
1555:  BTFSS  03.0
1556:  GOTO   563
....................   { pkt=pkt_1; 
*
1242:  MOVF   4C,W
1243:  MOVWF  44
1244:  MOVF   4B,W
1245:  MOVWF  43
1246:  MOVF   4A,W
1247:  MOVWF  42
1248:  MOVF   49,W
1249:  MOVWF  41
*
1557:  MOVF   4C,W
1558:  MOVWF  44
1559:  MOVF   4B,W
155A:  MOVWF  43
155B:  MOVF   4A,W
155C:  MOVWF  42
155D:  MOVF   49,W
155E:  MOVWF  41
....................   ukt=MI;      } 
*
124A:  CLRF   48
124B:  CLRF   47
124C:  CLRF   46
124D:  CLRF   45
*
155F:  CLRF   48
1560:  CLRF   47
1561:  CLRF   46
1562:  CLRF   45
....................  
....................   duty=ukt; 
*
124E:  MOVF   48,W
124F:  MOVLB  01
1250:  MOVWF  4C
1251:  MOVLB  00
1252:  MOVF   47,W
1253:  MOVLB  01
1254:  MOVWF  4B
1255:  MOVLB  00
1256:  MOVF   46,W
1257:  MOVLB  01
1258:  MOVWF  4A
1259:  MOVLB  00
125A:  MOVF   45,W
125B:  MOVLB  01
125C:  MOVWF  49
125D:  MOVLP  00
125E:  MOVLB  00
125F:  CALL   6ED
1260:  MOVLP  10
1261:  MOVF   79,W
1262:  MOVLB  01
1263:  MOVWF  27
1264:  MOVF   78,W
1265:  MOVWF  26
*
1563:  MOVF   48,W
1564:  MOVLB  01
1565:  MOVWF  4C
1566:  MOVLB  00
1567:  MOVF   47,W
1568:  MOVLB  01
1569:  MOVWF  4B
156A:  MOVLB  00
156B:  MOVF   46,W
156C:  MOVLB  01
156D:  MOVWF  4A
156E:  MOVLB  00
156F:  MOVF   45,W
1570:  MOVLB  01
1571:  MOVWF  49
1572:  MOVLP  00
1573:  MOVLB  00
1574:  CALL   6ED
1575:  MOVLP  10
1576:  MOVF   79,W
1577:  MOVLB  01
1578:  MOVWF  27
1579:  MOVF   78,W
157A:  MOVWF  26
....................   //D=calculos_pid(temp1); 
....................   D=(int16)duty; 
*
1266:  MOVF   27,W
1267:  MOVWF  4A
1268:  MOVF   26,W
1269:  MOVWF  49
126A:  MOVLP  00
126B:  MOVLB  00
126C:  CALL   388
126D:  MOVLP  10
126E:  MOVF   7A,W
126F:  MOVLB  01
1270:  MOVWF  2F
1271:  MOVF   79,W
1272:  MOVWF  2E
1273:  MOVF   78,W
1274:  MOVWF  2D
1275:  MOVF   77,W
1276:  MOVWF  2C
*
157B:  MOVF   27,W
157C:  MOVWF  4A
157D:  MOVF   26,W
157E:  MOVWF  49
157F:  MOVLP  00
1580:  MOVLB  00
1581:  CALL   388
1582:  MOVLP  10
1583:  MOVF   7A,W
1584:  MOVLB  01
1585:  MOVWF  2F
1586:  MOVF   79,W
1587:  MOVWF  2E
1588:  MOVF   78,W
1589:  MOVWF  2D
158A:  MOVF   77,W
158B:  MOVWF  2C
....................   Ct=((1000-D)); 
*
1277:  BSF    03.1
1278:  CLRF   50
1279:  CLRF   4F
127A:  MOVLW  7A
127B:  MOVWF  4E
127C:  MOVLW  88
127D:  MOVWF  4D
127E:  MOVF   2F,W
127F:  MOVWF  54
1280:  MOVF   2E,W
1281:  MOVWF  53
1282:  MOVF   2D,W
1283:  MOVWF  52
1284:  MOVF   2C,W
1285:  MOVWF  51
1286:  MOVLP  00
1287:  MOVLB  00
1288:  CALL   565
1289:  MOVLP  10
128A:  MOVF   7A,W
128B:  MOVLB  01
128C:  MOVWF  40
128D:  MOVF   79,W
128E:  MOVWF  3F
128F:  MOVF   78,W
1290:  MOVWF  3E
1291:  MOVF   77,W
1292:  MOVWF  3D
*
158C:  BSF    03.1
158D:  CLRF   50
158E:  CLRF   4F
158F:  MOVLW  7A
1590:  MOVWF  4E
1591:  MOVLW  88
1592:  MOVWF  4D
1593:  MOVF   2F,W
1594:  MOVWF  54
1595:  MOVF   2E,W
1596:  MOVWF  53
1597:  MOVF   2D,W
1598:  MOVWF  52
1599:  MOVF   2C,W
159A:  MOVWF  51
159B:  MOVLP  00
159C:  MOVLB  00
159D:  CALL   565
159E:  MOVLP  10
159F:  MOVF   7A,W
15A0:  MOVLB  01
15A1:  MOVWF  40
15A2:  MOVF   79,W
15A3:  MOVWF  3F
15A4:  MOVF   78,W
15A5:  MOVWF  3E
15A6:  MOVF   77,W
15A7:  MOVWF  3D
....................  
....................   pkt_1 = pkt ; 
*
1293:  MOVLB  00
1294:  MOVF   44,W
1295:  MOVWF  4C
1296:  MOVF   43,W
1297:  MOVWF  4B
1298:  MOVF   42,W
1299:  MOVWF  4A
129A:  MOVF   41,W
129B:  MOVWF  49
*
15A8:  MOVLB  00
15A9:  MOVF   44,W
15AA:  MOVWF  4C
15AB:  MOVF   43,W
15AC:  MOVWF  4B
15AD:  MOVF   42,W
15AE:  MOVWF  4A
15AF:  MOVF   41,W
15B0:  MOVWF  49
....................   ekt_1= ekt; 
*
129C:  MOVF   40,W
129D:  MOVWF  50
129E:  MOVF   3F,W
129F:  MOVWF  4F
12A0:  MOVF   3E,W
12A1:  MOVWF  4E
12A2:  MOVF   3D,W
12A3:  MOVWF  4D
*
15B1:  MOVF   40,W
15B2:  MOVWF  50
15B3:  MOVF   3F,W
15B4:  MOVWF  4F
15B5:  MOVF   3E,W
15B6:  MOVWF  4E
15B7:  MOVF   3D,W
15B8:  MOVWF  4D
....................               
....................  return ct;  
*
12A4:  MOVLB  01
12A5:  MOVF   3D,W
12A6:  MOVWF  77
12A7:  MOVF   3E,W
12A8:  MOVWF  78
12A9:  MOVF   3F,W
12AA:  MOVWF  79
12AB:  MOVF   40,W
12AC:  MOVWF  7A
*
15B9:  MOVLB  01
15BA:  MOVF   3D,W
15BB:  MOVWF  77
15BC:  MOVF   3E,W
15BD:  MOVWF  78
15BE:  MOVF   3F,W
15BF:  MOVWF  79
15C0:  MOVF   40,W
15C1:  MOVWF  7A
.................... } 
....................  
.................... //CALCULOS PID 
.................... float calculos_pid(float t1,int SP1) { 
....................         float ctd; 
.................... rktd=SP1; 
*
0A24:  MOVLB  01
0A25:  CLRF   4A
0A26:  MOVF   41,W
0A27:  MOVWF  49
0A28:  MOVLP  00
0A29:  MOVLB  00
0A2A:  CALL   388
0A2B:  MOVLP  08
0A2C:  MOVF   7A,W
0A2D:  MOVWF  54
0A2E:  MOVF   79,W
0A2F:  MOVWF  53
0A30:  MOVF   78,W
0A31:  MOVWF  52
0A32:  MOVF   77,W
0A33:  MOVWF  51
....................  
....................   /* Calculate error */ 
....................   ektd=rktd-t1; 
0A34:  BSF    03.1
0A35:  MOVF   54,W
0A36:  MOVLB  01
0A37:  MOVWF  50
0A38:  MOVLB  00
0A39:  MOVF   53,W
0A3A:  MOVLB  01
0A3B:  MOVWF  4F
0A3C:  MOVLB  00
0A3D:  MOVF   52,W
0A3E:  MOVLB  01
0A3F:  MOVWF  4E
0A40:  MOVLB  00
0A41:  MOVF   51,W
0A42:  MOVLB  01
0A43:  MOVWF  4D
0A44:  MOVF   40,W
0A45:  MOVWF  54
0A46:  MOVF   3F,W
0A47:  MOVWF  53
0A48:  MOVF   3E,W
0A49:  MOVWF  52
0A4A:  MOVF   3D,W
0A4B:  MOVWF  51
0A4C:  MOVLP  00
0A4D:  MOVLB  00
0A4E:  CALL   565
0A4F:  MOVLP  08
0A50:  MOVF   7A,W
0A51:  MOVWF  58
0A52:  MOVF   79,W
0A53:  MOVWF  57
0A54:  MOVF   78,W
0A55:  MOVWF  56
0A56:  MOVF   77,W
0A57:  MOVWF  55
....................   /*end  Calculate error */ 
....................  
....................   /* Calculate I term */ 
....................   pktd=b1*ektd+pktd_1; 
0A58:  MOVLW  66
0A59:  MOVLB  01
0A5A:  MOVWF  53
0A5B:  MOVWF  52
0A5C:  MOVLW  26
0A5D:  MOVWF  51
0A5E:  MOVLW  7F
0A5F:  MOVWF  50
0A60:  MOVLB  00
0A61:  MOVF   58,W
0A62:  MOVLB  01
0A63:  MOVWF  57
0A64:  MOVLB  00
0A65:  MOVF   57,W
0A66:  MOVLB  01
0A67:  MOVWF  56
0A68:  MOVLB  00
0A69:  MOVF   56,W
0A6A:  MOVLB  01
0A6B:  MOVWF  55
0A6C:  MOVLB  00
0A6D:  MOVF   55,W
0A6E:  MOVLB  01
0A6F:  MOVWF  54
0A70:  MOVLP  00
0A71:  MOVLB  00
0A72:  CALL   3A7
0A73:  MOVLP  08
0A74:  MOVF   7A,W
0A75:  MOVLB  01
0A76:  MOVWF  4B
0A77:  MOVF   79,W
0A78:  MOVWF  4A
0A79:  MOVF   78,W
0A7A:  MOVWF  49
0A7B:  MOVF   77,W
0A7C:  MOVWF  48
0A7D:  BCF    03.1
0A7E:  MOVF   4B,W
0A7F:  MOVWF  50
0A80:  MOVF   4A,W
0A81:  MOVWF  4F
0A82:  MOVF   49,W
0A83:  MOVWF  4E
0A84:  MOVF   48,W
0A85:  MOVWF  4D
0A86:  MOVLB  00
0A87:  MOVF   68,W
0A88:  MOVLB  01
0A89:  MOVWF  54
0A8A:  MOVLB  00
0A8B:  MOVF   67,W
0A8C:  MOVLB  01
0A8D:  MOVWF  53
0A8E:  MOVLB  00
0A8F:  MOVF   66,W
0A90:  MOVLB  01
0A91:  MOVWF  52
0A92:  MOVLB  00
0A93:  MOVF   65,W
0A94:  MOVLB  01
0A95:  MOVWF  51
0A96:  MOVLP  00
0A97:  MOVLB  00
0A98:  CALL   565
0A99:  MOVLP  08
0A9A:  MOVF   7A,W
0A9B:  MOVWF  5C
0A9C:  MOVF   79,W
0A9D:  MOVWF  5B
0A9E:  MOVF   78,W
0A9F:  MOVWF  5A
0AA0:  MOVF   77,W
0AA1:  MOVWF  59
....................   /*end  Calculate I term */ 
....................    
....................   /* Calculate D term */  
....................      qktd=c*(ektd-ektd_1); 
0AA2:  BSF    03.1
0AA3:  MOVF   58,W
0AA4:  MOVLB  01
0AA5:  MOVWF  50
0AA6:  MOVLB  00
0AA7:  MOVF   57,W
0AA8:  MOVLB  01
0AA9:  MOVWF  4F
0AAA:  MOVLB  00
0AAB:  MOVF   56,W
0AAC:  MOVLB  01
0AAD:  MOVWF  4E
0AAE:  MOVLB  00
0AAF:  MOVF   55,W
0AB0:  MOVLB  01
0AB1:  MOVWF  4D
0AB2:  MOVLB  00
0AB3:  MOVF   6C,W
0AB4:  MOVLB  01
0AB5:  MOVWF  54
0AB6:  MOVLB  00
0AB7:  MOVF   6B,W
0AB8:  MOVLB  01
0AB9:  MOVWF  53
0ABA:  MOVLB  00
0ABB:  MOVF   6A,W
0ABC:  MOVLB  01
0ABD:  MOVWF  52
0ABE:  MOVLB  00
0ABF:  MOVF   69,W
0AC0:  MOVLB  01
0AC1:  MOVWF  51
0AC2:  MOVLP  00
0AC3:  MOVLB  00
0AC4:  CALL   565
0AC5:  MOVLP  08
0AC6:  MOVLW  CD
0AC7:  MOVLB  01
0AC8:  MOVWF  53
0AC9:  MOVLW  CC
0ACA:  MOVWF  52
0ACB:  MOVLW  4C
0ACC:  MOVWF  51
0ACD:  MOVLW  80
0ACE:  MOVWF  50
0ACF:  MOVF   7A,W
0AD0:  MOVWF  57
0AD1:  MOVF   79,W
0AD2:  MOVWF  56
0AD3:  MOVF   78,W
0AD4:  MOVWF  55
0AD5:  MOVF   77,W
0AD6:  MOVWF  54
0AD7:  MOVLP  00
0AD8:  MOVLB  00
0AD9:  CALL   3A7
0ADA:  MOVLP  08
0ADB:  MOVF   7A,W
0ADC:  MOVWF  60
0ADD:  MOVF   79,W
0ADE:  MOVWF  5F
0ADF:  MOVF   78,W
0AE0:  MOVWF  5E
0AE1:  MOVF   77,W
0AE2:  MOVWF  5D
....................  
....................   /* Calculate PI output */ 
....................    uktd=pktd+a1*ektd+qktd; 
0AE3:  MOVLW  0A
0AE4:  MOVLB  01
0AE5:  MOVWF  53
0AE6:  MOVLW  D7
0AE7:  MOVWF  52
0AE8:  MOVLW  5B
0AE9:  MOVWF  51
0AEA:  MOVLW  82
0AEB:  MOVWF  50
0AEC:  MOVLB  00
0AED:  MOVF   58,W
0AEE:  MOVLB  01
0AEF:  MOVWF  57
0AF0:  MOVLB  00
0AF1:  MOVF   57,W
0AF2:  MOVLB  01
0AF3:  MOVWF  56
0AF4:  MOVLB  00
0AF5:  MOVF   56,W
0AF6:  MOVLB  01
0AF7:  MOVWF  55
0AF8:  MOVLB  00
0AF9:  MOVF   55,W
0AFA:  MOVLB  01
0AFB:  MOVWF  54
0AFC:  MOVLP  00
0AFD:  MOVLB  00
0AFE:  CALL   3A7
0AFF:  MOVLP  08
0B00:  BCF    03.1
0B01:  MOVF   5C,W
0B02:  MOVLB  01
0B03:  MOVWF  50
0B04:  MOVLB  00
0B05:  MOVF   5B,W
0B06:  MOVLB  01
0B07:  MOVWF  4F
0B08:  MOVLB  00
0B09:  MOVF   5A,W
0B0A:  MOVLB  01
0B0B:  MOVWF  4E
0B0C:  MOVLB  00
0B0D:  MOVF   59,W
0B0E:  MOVLB  01
0B0F:  MOVWF  4D
0B10:  MOVF   7A,W
0B11:  MOVWF  54
0B12:  MOVF   79,W
0B13:  MOVWF  53
0B14:  MOVF   78,W
0B15:  MOVWF  52
0B16:  MOVF   77,W
0B17:  MOVWF  51
0B18:  MOVLP  00
0B19:  MOVLB  00
0B1A:  CALL   565
0B1B:  MOVLP  08
0B1C:  MOVF   7A,W
0B1D:  MOVLB  01
0B1E:  MOVWF  4B
0B1F:  MOVF   79,W
0B20:  MOVWF  4A
0B21:  MOVF   78,W
0B22:  MOVWF  49
0B23:  MOVF   77,W
0B24:  MOVWF  48
0B25:  BCF    03.1
0B26:  MOVF   4B,W
0B27:  MOVWF  50
0B28:  MOVF   4A,W
0B29:  MOVWF  4F
0B2A:  MOVF   49,W
0B2B:  MOVWF  4E
0B2C:  MOVF   48,W
0B2D:  MOVWF  4D
0B2E:  MOVLB  00
0B2F:  MOVF   60,W
0B30:  MOVLB  01
0B31:  MOVWF  54
0B32:  MOVLB  00
0B33:  MOVF   5F,W
0B34:  MOVLB  01
0B35:  MOVWF  53
0B36:  MOVLB  00
0B37:  MOVF   5E,W
0B38:  MOVLB  01
0B39:  MOVWF  52
0B3A:  MOVLB  00
0B3B:  MOVF   5D,W
0B3C:  MOVLB  01
0B3D:  MOVWF  51
0B3E:  MOVLP  00
0B3F:  MOVLB  00
0B40:  CALL   565
0B41:  MOVLP  08
0B42:  MOVF   7A,W
0B43:  MOVWF  64
0B44:  MOVF   79,W
0B45:  MOVWF  63
0B46:  MOVF   78,W
0B47:  MOVWF  62
0B48:  MOVF   77,W
0B49:  MOVWF  61
....................   /*end Calculate PI output */ 
....................  
....................   if(uktd > MA) { 
0B4A:  MOVLB  01
0B4B:  CLRF   4C
0B4C:  CLRF   4B
0B4D:  MOVLW  7A
0B4E:  MOVWF  4A
0B4F:  MOVLW  88
0B50:  MOVWF  49
0B51:  MOVLB  00
0B52:  MOVF   64,W
0B53:  MOVLB  01
0B54:  MOVWF  50
0B55:  MOVLB  00
0B56:  MOVF   63,W
0B57:  MOVLB  01
0B58:  MOVWF  4F
0B59:  MOVLB  00
0B5A:  MOVF   62,W
0B5B:  MOVLB  01
0B5C:  MOVWF  4E
0B5D:  MOVLB  00
0B5E:  MOVF   61,W
0B5F:  MOVLB  01
0B60:  MOVWF  4D
0B61:  MOVLP  00
0B62:  MOVLB  00
0B63:  CALL   6AC
0B64:  MOVLP  08
0B65:  BTFSS  03.0
0B66:  GOTO   376
....................   pktd=pktd_1; 
0B67:  MOVF   68,W
0B68:  MOVWF  5C
0B69:  MOVF   67,W
0B6A:  MOVWF  5B
0B6B:  MOVF   66,W
0B6C:  MOVWF  5A
0B6D:  MOVF   65,W
0B6E:  MOVWF  59
....................   uktd =MA;     } 
0B6F:  CLRF   64
0B70:  CLRF   63
0B71:  MOVLW  7A
0B72:  MOVWF  62
0B73:  MOVLW  88
0B74:  MOVWF  61
0B75:  GOTO   39B
....................   else if(uktd < MI) 
0B76:  MOVF   64,W
0B77:  MOVLB  01
0B78:  MOVWF  4C
0B79:  MOVLB  00
0B7A:  MOVF   63,W
0B7B:  MOVLB  01
0B7C:  MOVWF  4B
0B7D:  MOVLB  00
0B7E:  MOVF   62,W
0B7F:  MOVLB  01
0B80:  MOVWF  4A
0B81:  MOVLB  00
0B82:  MOVF   61,W
0B83:  MOVLB  01
0B84:  MOVWF  49
0B85:  CLRF   50
0B86:  CLRF   4F
0B87:  CLRF   4E
0B88:  CLRF   4D
0B89:  MOVLP  00
0B8A:  MOVLB  00
0B8B:  CALL   6AC
0B8C:  MOVLP  08
0B8D:  BTFSS  03.0
0B8E:  GOTO   39B
....................   { pktd=pktd_1; 
0B8F:  MOVF   68,W
0B90:  MOVWF  5C
0B91:  MOVF   67,W
0B92:  MOVWF  5B
0B93:  MOVF   66,W
0B94:  MOVWF  5A
0B95:  MOVF   65,W
0B96:  MOVWF  59
....................   uktd=MI;      } 
0B97:  CLRF   64
0B98:  CLRF   63
0B99:  CLRF   62
0B9A:  CLRF   61
....................  
....................   dutyd=uktd; 
0B9B:  MOVF   64,W
0B9C:  MOVLB  01
0B9D:  MOVWF  4C
0B9E:  MOVLB  00
0B9F:  MOVF   63,W
0BA0:  MOVLB  01
0BA1:  MOVWF  4B
0BA2:  MOVLB  00
0BA3:  MOVF   62,W
0BA4:  MOVLB  01
0BA5:  MOVWF  4A
0BA6:  MOVLB  00
0BA7:  MOVF   61,W
0BA8:  MOVLB  01
0BA9:  MOVWF  49
0BAA:  MOVLP  00
0BAB:  MOVLB  00
0BAC:  CALL   6ED
0BAD:  MOVLP  08
0BAE:  MOVF   79,W
0BAF:  MOVLB  01
0BB0:  MOVWF  21
0BB1:  MOVF   78,W
0BB2:  MOVWF  20
....................   Dd=(int16)dutyd; 
0BB3:  MOVF   21,W
0BB4:  MOVWF  4A
0BB5:  MOVF   20,W
0BB6:  MOVWF  49
0BB7:  MOVLP  00
0BB8:  MOVLB  00
0BB9:  CALL   388
0BBA:  MOVLP  08
0BBB:  MOVF   7A,W
0BBC:  MOVLB  01
0BBD:  MOVWF  33
0BBE:  MOVF   79,W
0BBF:  MOVWF  32
0BC0:  MOVF   78,W
0BC1:  MOVWF  31
0BC2:  MOVF   77,W
0BC3:  MOVWF  30
....................   Ctd=((1000-Dd)); 
0BC4:  BSF    03.1
0BC5:  CLRF   50
0BC6:  CLRF   4F
0BC7:  MOVLW  7A
0BC8:  MOVWF  4E
0BC9:  MOVLW  88
0BCA:  MOVWF  4D
0BCB:  MOVF   33,W
0BCC:  MOVWF  54
0BCD:  MOVF   32,W
0BCE:  MOVWF  53
0BCF:  MOVF   31,W
0BD0:  MOVWF  52
0BD1:  MOVF   30,W
0BD2:  MOVWF  51
0BD3:  MOVLP  00
0BD4:  MOVLB  00
0BD5:  CALL   565
0BD6:  MOVLP  08
0BD7:  MOVF   7A,W
0BD8:  MOVLB  01
0BD9:  MOVWF  45
0BDA:  MOVF   79,W
0BDB:  MOVWF  44
0BDC:  MOVF   78,W
0BDD:  MOVWF  43
0BDE:  MOVF   77,W
0BDF:  MOVWF  42
....................  
....................   pktd_1 = pktd ; 
0BE0:  MOVLB  00
0BE1:  MOVF   5C,W
0BE2:  MOVWF  68
0BE3:  MOVF   5B,W
0BE4:  MOVWF  67
0BE5:  MOVF   5A,W
0BE6:  MOVWF  66
0BE7:  MOVF   59,W
0BE8:  MOVWF  65
....................   ektd_1= ektd; 
0BE9:  MOVF   58,W
0BEA:  MOVWF  6C
0BEB:  MOVF   57,W
0BEC:  MOVWF  6B
0BED:  MOVF   56,W
0BEE:  MOVWF  6A
0BEF:  MOVF   55,W
0BF0:  MOVWF  69
....................                  
....................  return ctd;  
0BF1:  MOVLB  01
0BF2:  MOVF   42,W
0BF3:  MOVWF  77
0BF4:  MOVF   43,W
0BF5:  MOVWF  78
0BF6:  MOVF   44,W
0BF7:  MOVWF  79
0BF8:  MOVF   45,W
0BF9:  MOVWF  7A
0BFA:  MOVLP  10
0BFB:  MOVLB  00
0BFC:  GOTO   71D (RETURN)
.................... } 
....................  
.................... //TIMER 0 CICLOS 
.................... #int_timer0 
.................... void int_tiempo0(void){ 
.................... ++contRTCC; 
*
00E9:  INCF   30,F
.................... if(contRTCC==155){ 
00EA:  MOVF   30,W
00EB:  SUBLW  9B
00EC:  BTFSS  03.2
00ED:  GOTO   0FA
....................  
.................... flag=1; 
00EE:  MOVLW  01
00EF:  MOVWF  72
.................... output_toggle(PIN_C6); 
00F0:  MOVLB  01
00F1:  BCF    0E.6
00F2:  MOVLW  40
00F3:  MOVLB  02
00F4:  XORWF  0E,F
.................... delay_ms(10); 
00F5:  MOVLW  0A
00F6:  MOVLB  01
00F7:  MOVWF  6C
00F8:  MOVLB  00
00F9:  CALL   04C
....................            
....................  //promedio de medicion  
....................   }            
....................  
.................... if(contRTCC==310){ 
00FA:  MOVF   30,W
00FB:  SUBLW  36
00FC:  BTFSS  03.2
00FD:  GOTO   10F
....................  
.................... delay_ms(10); 
00FE:  MOVLW  0A
00FF:  MOVLB  01
0100:  MOVWF  6C
0101:  MOVLB  00
0102:  CALL   04C
.................... flag=0; 
0103:  CLRF   72
.................... output_toggle(PIN_C6); 
0104:  MOVLB  01
0105:  BCF    0E.6
0106:  MOVLW  40
0107:  MOVLB  02
0108:  XORWF  0E,F
.................... delay_ms(10); 
0109:  MOVLW  0A
010A:  MOVLB  01
010B:  MOVWF  6C
010C:  MOVLB  00
010D:  CALL   04C
....................            
....................  //promedio de medicion  
....................    contRTCC=0; 
010E:  CLRF   30
.................... } 
010F:  BCF    0B.2
0110:  MOVLP  00
0111:  GOTO   02A
.................... } 
....................  
.................... void main(void){ 
*
1000:  MOVLW  34
1001:  MOVLB  01
1002:  MOVWF  19
1003:  CLRF   18
1004:  MOVLB  00
1005:  CLRF   2F
1006:  MOVLB  03
1007:  BCF    1F.3
1008:  MOVLW  19
1009:  MOVWF  1B
100A:  MOVLW  A6
100B:  MOVWF  1E
100C:  MOVLW  90
100D:  MOVWF  1D
100E:  MOVLW  F9
100F:  MOVLB  00
1010:  MOVWF  1B
1011:  MOVLW  05
1012:  MOVWF  1C
1013:  MOVLB  01
1014:  BCF    0E.5
1015:  MOVLW  7D
1016:  MOVLB  0C
1017:  MOVWF  12
1018:  CLRF   11
1019:  MOVLW  C0
101A:  MOVWF  13
101B:  MOVLB  00
101C:  CLRF   30
101D:  CLRF   4C
101E:  CLRF   4B
101F:  CLRF   4A
1020:  CLRF   49
1021:  CLRF   50
1022:  CLRF   4F
1023:  CLRF   4E
1024:  CLRF   4D
1025:  CLRF   68
1026:  CLRF   67
1027:  CLRF   66
1028:  CLRF   65
1029:  CLRF   6C
102A:  CLRF   6B
102B:  CLRF   6A
102C:  CLRF   69
102D:  MOVLW  3C
102E:  MOVWF  6F
102F:  MOVLB  01
1030:  CLRF   39
1031:  CLRF   38
1032:  MOVLB  03
1033:  CLRF   0C
1034:  CLRF   0D
1035:  CLRF   0E
1036:  MOVLB  02
1037:  CLRF   12
1038:  CLRF   11
1039:  CLRF   14
103A:  CLRF   13
103B:  MOVLB  00
103C:  CLRF   29
103D:  CLRF   2A
.................... int SPTU; 
.................... char v[2]; 
....................  
....................  
....................    PWM_ON(P1);                 //configuracion del pwm 
103E:  MOVLB  0C
103F:  BSF    13.7
....................    PWM_SET_FREQUENCY(P1,1000); 
1040:  MOVLB  01
1041:  CLRF   40
1042:  CLRF   3F
1043:  MOVLW  03
1044:  MOVWF  3E
1045:  MOVLW  E8
1046:  MOVWF  3D
1047:  CLRF   44
1048:  MOVLW  0F
1049:  MOVWF  43
104A:  MOVLW  42
104B:  MOVWF  42
104C:  MOVLW  40
104D:  MOVWF  41
104E:  MOVLP  00
104F:  MOVLB  00
1050:  GOTO   1C7
1051:  MOVLP  10
....................    PWM1CON=0xE0; 
1052:  MOVLW  E0
1053:  MOVLB  0C
1054:  MOVWF  13
....................   // setup_oscillator(OSC_8MHZ | OSC_INTRC); //ajustando oscilador interno 
....................    setup_comparator(NC_NC_NC_NC); 
1055:  MOVLW  30
1056:  MOVLB  02
1057:  MOVWF  12
1058:  CLRF   11
1059:  MOVWF  14
105A:  CLRF   13
....................    setup_vref(FALSE); 
105B:  CLRF   17
....................    setup_wdt(WDT_OFF); 
105C:  MOVLB  01
105D:  BCF    17.0
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_128); // Desborde del timer cada T1 = 32.768ms-> 4MHZ T = 16.384ms-> 8MHZ -> T=(4/fosc * PREESCALER )(256-Carga en el timer)   T-> Periodo de desborde del timer.  
105E:  MOVF   15,W
105F:  ANDLW  C0
1060:  IORLW  06
1061:  MOVWF  15
....................    setup_timer_1(T1_DISABLED); 
1062:  MOVLB  02
1063:  BCF    1D.3
1064:  MOVLB  00
1065:  CLRF   18
1066:  CLRF   19
....................    setup_timer_2(T2_DIV_BY_4, 250, 1); 
1067:  MOVLW  00
1068:  MOVWF  78
1069:  IORLW  05
106A:  MOVWF  1C
106B:  MOVLW  FA
106C:  MOVWF  1B
....................    enable_interrupts(INT_TIMER0); 
106D:  BSF    0B.5
....................    enable_interrupts(INT_RDA); 
106E:  MOVLB  01
106F:  BSF    11.5
....................    enable_interrupts(global); 
1070:  MOVLW  C0
1071:  IORWF  0B,F
....................    set_tris_A(0x10); 
1072:  MOVLW  10
1073:  MOVWF  0C
....................    set_tris_c(0x04);               
1074:  MOVLW  04
1075:  MOVWF  0E
....................    set_tris_B(0x30);               //entradas y salidas del puerto B prioridad Entrada RS232 
1076:  MOVLW  30
1077:  MOVWF  0D
....................    setup_adc_ports(sAN6|VSS_VDD); 
1078:  BCF    1E.0
1079:  BCF    1E.1
107A:  MOVLW  00
107B:  MOVLB  03
107C:  MOVWF  0C
107D:  MOVLW  04
107E:  MOVWF  0E
107F:  MOVLW  00
1080:  MOVWF  0D
....................    setup_adc(ADC_CLOCK_INTERNAL); 
1081:  MOVLB  01
1082:  BSF    1E.4
1083:  BSF    1E.5
1084:  BCF    1E.6
1085:  BSF    1E.7
1086:  BSF    1D.0
....................    set_adc_channel(6); 
1087:  MOVLW  18
1088:  MOVWF  78
1089:  MOVF   1D,W
108A:  ANDLW  83
108B:  IORWF  78,W
108C:  MOVWF  1D
....................    lcd_init();                   //Inicializamos el LCD. 
108D:  MOVLP  00
108E:  MOVLB  00
108F:  GOTO   29F
1090:  MOVLP  10
....................       lcd_putc("\fSetpoint");      //65 
1091:  MOVLW  12
1092:  MOVLB  03
1093:  MOVWF  11
1094:  MOVLW  01
1095:  MOVWF  12
1096:  MOVLP  00
1097:  MOVLB  00
1098:  CALL   33A
1099:  MOVLP  10
....................       valor=read_adc(); 
109A:  MOVLB  01
109B:  BSF    1D.1
109C:  BTFSC  1D.1
109D:  GOTO   09C
109E:  MOVF   1B,W
109F:  MOVWF  22
10A0:  MOVF   1C,W
10A1:  MOVWF  23
10A2:  MOVLB  00
10A3:  CLRF   28
10A4:  BTFSC  0B.7
10A5:  BSF    28.7
10A6:  BCF    0B.7
....................       delay_ms(5); 
10A7:  MOVLW  05
10A8:  MOVLB  01
10A9:  MOVWF  6C
10AA:  MOVLP  00
10AB:  MOVLB  00
10AC:  CALL   04C
10AD:  MOVLP  10
10AE:  BTFSC  28.7
10AF:  BSF    0B.7
....................       temp1=calculos_rtd(valor); 
10B0:  MOVLB  01
10B1:  MOVF   23,W
10B2:  MOVWF  3E
10B3:  MOVF   22,W
10B4:  MOVWF  3D
10B5:  MOVLP  00
10B6:  MOVLB  00
10B7:  CALL   41E
10B8:  MOVLP  10
10B9:  MOVF   7A,W
10BA:  MOVLB  01
10BB:  MOVWF  2B
10BC:  MOVF   79,W
10BD:  MOVWF  2A
10BE:  MOVF   78,W
10BF:  MOVWF  29
10C0:  MOVF   77,W
10C1:  MOVWF  28
....................       lcd_gotoxy(10,2); 
10C2:  MOVLW  0A
10C3:  MOVWF  51
10C4:  MOVLW  02
10C5:  MOVWF  52
10C6:  MOVLP  00
10C7:  MOVLB  00
10C8:  CALL   2F0
10C9:  MOVLP  10
....................       printf(lcd_putc,"T%4.2f",temp1); 
10CA:  MOVLW  54
10CB:  MOVLB  01
10CC:  MOVWF  50
10CD:  MOVLP  00
10CE:  MOVLB  00
10CF:  CALL   304
10D0:  MOVLP  10
10D1:  MOVLW  03
10D2:  MOVWF  04
10D3:  MOVLB  01
10D4:  MOVF   2B,W
10D5:  MOVWF  40
10D6:  MOVF   2A,W
10D7:  MOVWF  3F
10D8:  MOVF   29,W
10D9:  MOVWF  3E
10DA:  MOVF   28,W
10DB:  MOVWF  3D
10DC:  MOVLW  02
10DD:  MOVWF  41
10DE:  MOVLP  00
10DF:  MOVLB  00
10E0:  CALL   48B
10E1:  MOVLP  10
10E2:  CLRF   28
10E3:  BTFSC  0B.7
10E4:  BSF    28.7
10E5:  BCF    0B.7
....................       delay_ms(10);     
10E6:  MOVLW  0A
10E7:  MOVLB  01
10E8:  MOVWF  6C
10E9:  MOVLP  00
10EA:  MOVLB  00
10EB:  CALL   04C
10EC:  MOVLP  10
10ED:  BTFSC  28.7
10EE:  BSF    0B.7
....................       lcd_putc("\f"); 
10EF:  MOVLW  03
10F0:  MOVLB  03
10F1:  MOVWF  11
10F2:  MOVLW  00
10F3:  MOVWF  12
10F4:  MOVLP  00
10F5:  MOVLB  00
10F6:  CALL   33A
10F7:  MOVLP  10
....................       state = Esperando;                                                                                           
10F8:  CLRF   74
.................... while(1){ 
....................    v[0]=g[0];   
10F9:  MOVF   73,W
10FA:  MOVLB  01
10FB:  MOVWF  3B
10FC:  MOVLB  00
10FD:  CLRF   28
10FE:  BTFSC  0B.7
10FF:  BSF    28.7
1100:  BCF    0B.7
....................    delay_ms(10); 
1101:  MOVLW  0A
1102:  MOVLB  01
1103:  MOVWF  6C
1104:  MOVLP  00
1105:  MOVLB  00
1106:  CALL   04C
1107:  MOVLP  10
1108:  BTFSC  28.7
1109:  BSF    0B.7
....................  switch (state) 
110A:  MOVF   74,W
110B:  ADDLW  FA
110C:  BTFSC  03.0
110D:  GOTO   7E6
110E:  ADDLW  06
110F:  GOTO   7E8
....................            { 
....................             case Esperando:  
....................            {   
....................             v[0]=g[0]; 
1110:  MOVF   73,W
1111:  MOVLB  01
1112:  MOVWF  3B
....................  
....................           if(flag==1)  { 
1113:  DECFSZ 72,W
1114:  GOTO   12B
....................            valor=read_adc(); 
1115:  BSF    1D.1
1116:  BTFSC  1D.1
1117:  GOTO   116
1118:  MOVF   1B,W
1119:  MOVWF  22
111A:  MOVF   1C,W
111B:  MOVWF  23
111C:  MOVLB  00
111D:  CLRF   28
111E:  BTFSC  0B.7
111F:  BSF    28.7
1120:  BCF    0B.7
....................            delay_ms(10); 
1121:  MOVLW  0A
1122:  MOVLB  01
1123:  MOVWF  6C
1124:  MOVLP  00
1125:  MOVLB  00
1126:  CALL   04C
1127:  MOVLP  10
1128:  BTFSC  28.7
1129:  BSF    0B.7
112A:  MOVLB  01
....................  
....................            }      
....................             
....................             temp1=calculos_rtd(valor); 
112B:  MOVF   23,W
112C:  MOVWF  3E
112D:  MOVF   22,W
112E:  MOVWF  3D
112F:  MOVLP  00
1130:  MOVLB  00
1131:  CALL   41E
1132:  MOVLP  10
1133:  MOVF   7A,W
1134:  MOVLB  01
1135:  MOVWF  2B
1136:  MOVF   79,W
1137:  MOVWF  2A
1138:  MOVF   78,W
1139:  MOVWF  29
113A:  MOVF   77,W
113B:  MOVWF  28
....................             Control=calculos_pi(temp1,Set_point); 
*
12AD:  MOVF   7A,W
12AE:  MOVWF  4C
12AF:  MOVF   79,W
12B0:  MOVWF  4B
12B1:  MOVF   78,W
12B2:  MOVWF  4A
12B3:  MOVF   77,W
12B4:  MOVWF  49
12B5:  MOVLP  00
12B6:  MOVLB  00
12B7:  CALL   6ED
12B8:  MOVLP  10
12B9:  MOVF   79,W
12BA:  MOVLB  01
12BB:  MOVWF  25
12BC:  MOVF   78,W
12BD:  MOVWF  24
....................             set_pwm1_duty(Control); 
12BE:  MOVF   25,W
12BF:  MOVWF  79
12C0:  MOVF   24,W
12C1:  MOVWF  78
12C2:  RLF    78,F
12C3:  RLF    79,F
12C4:  RLF    78,F
12C5:  RLF    79,F
12C6:  RLF    78,F
12C7:  RLF    79,F
12C8:  RLF    78,F
12C9:  RLF    79,F
12CA:  RLF    78,F
12CB:  RLF    79,F
12CC:  RLF    78,F
12CD:  RLF    79,F
12CE:  MOVF   79,W
12CF:  MOVLB  0C
12D0:  MOVWF  12
12D1:  MOVF   78,W
12D2:  MOVWF  11
....................             //lcd_putc("Setpoint"); 
....................             lcd_gotoxy(1,1);  
12D3:  MOVLW  01
12D4:  MOVLB  01
12D5:  MOVWF  51
12D6:  MOVWF  52
12D7:  MOVLP  00
12D8:  MOVLB  00
12D9:  CALL   2F0
12DA:  MOVLP  10
....................             printf(lcd_putc,"\fSetpoint V: %d",Set_point); 
12DB:  MOVLW  17
12DC:  MOVLB  03
12DD:  MOVWF  11
12DE:  MOVLW  01
12DF:  MOVWF  12
12E0:  BCF    03.0
12E1:  MOVLW  0D
12E2:  MOVLB  01
12E3:  MOVWF  3D
12E4:  MOVLP  00
12E5:  MOVLB  00
12E6:  CALL   70E
12E7:  MOVLP  10
12E8:  MOVF   6F,W
12E9:  MOVLB  01
12EA:  MOVWF  3D
12EB:  MOVLW  18
12EC:  MOVWF  3E
12ED:  MOVLP  00
12EE:  MOVLB  00
12EF:  CALL   77D
12F0:  MOVLP  10
12F1:  CLRF   28
12F2:  BTFSC  0B.7
12F3:  BSF    28.7
12F4:  BCF    0B.7
....................             delay_ms(10); 
12F5:  MOVLW  0A
12F6:  MOVLB  01
12F7:  MOVWF  6C
12F8:  MOVLP  00
12F9:  MOVLB  00
12FA:  CALL   04C
12FB:  MOVLP  10
12FC:  BTFSC  28.7
12FD:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
12FE:  MOVLW  01
12FF:  MOVLB  01
1300:  MOVWF  51
1301:  MOVLW  02
1302:  MOVWF  52
1303:  MOVLP  00
1304:  MOVLB  00
1305:  CALL   2F0
1306:  MOVLP  10
....................             printf(lcd_putc,"D:%4lu T:%4.2f",Control,temp1); 
1307:  MOVLW  44
1308:  MOVLB  01
1309:  MOVWF  50
130A:  MOVLP  00
130B:  MOVLB  00
130C:  CALL   304
130D:  MOVLP  10
130E:  MOVLW  3A
130F:  MOVLB  01
1310:  MOVWF  50
1311:  MOVLP  00
1312:  MOVLB  00
1313:  CALL   304
1314:  MOVLP  10
1315:  MOVLW  01
1316:  MOVWF  04
1317:  MOVLB  01
1318:  MOVF   25,W
1319:  MOVWF  3E
131A:  MOVF   24,W
131B:  MOVWF  3D
131C:  MOVLP  08
131D:  MOVLB  00
131E:  CALL   000
131F:  MOVLP  10
1320:  MOVLW  20
1321:  MOVLB  01
1322:  MOVWF  50
1323:  MOVLP  00
1324:  MOVLB  00
1325:  CALL   304
1326:  MOVLP  10
1327:  MOVLW  54
1328:  MOVLB  01
1329:  MOVWF  50
132A:  MOVLP  00
132B:  MOVLB  00
132C:  CALL   304
132D:  MOVLP  10
132E:  MOVLW  3A
132F:  MOVLB  01
1330:  MOVWF  50
1331:  MOVLP  00
1332:  MOVLB  00
1333:  CALL   304
1334:  MOVLP  10
1335:  MOVLW  03
1336:  MOVWF  04
1337:  MOVLB  01
1338:  MOVF   2B,W
1339:  MOVWF  40
133A:  MOVF   2A,W
133B:  MOVWF  3F
133C:  MOVF   29,W
133D:  MOVWF  3E
133E:  MOVF   28,W
133F:  MOVWF  3D
1340:  MOVLW  02
1341:  MOVWF  41
1342:  MOVLP  00
1343:  MOVLB  00
1344:  CALL   48B
1345:  MOVLP  10
1346:  CLRF   28
1347:  BTFSC  0B.7
1348:  BSF    28.7
1349:  BCF    0B.7
....................             delay_ms(10); 
134A:  MOVLW  0A
134B:  MOVLB  01
134C:  MOVWF  6C
134D:  MOVLP  00
134E:  MOVLB  00
134F:  CALL   04C
1350:  MOVLP  10
1351:  BTFSC  28.7
1352:  BSF    0B.7
....................             envioUART(temp1); 
1353:  MOVLB  01
1354:  MOVF   2B,W
1355:  MOVWF  40
1356:  MOVF   2A,W
1357:  MOVWF  3F
1358:  MOVF   29,W
1359:  MOVWF  3E
135A:  MOVF   28,W
135B:  MOVWF  3D
135C:  MOVLP  08
135D:  MOVLB  00
135E:  CALL   156
135F:  MOVLP  10
....................             printf("DEFAULT"); 
1360:  MOVLW  1F
1361:  MOVLB  03
1362:  MOVWF  11
1363:  MOVLW  01
1364:  MOVWF  12
1365:  MOVLP  08
1366:  MOVLB  00
1367:  CALL   1D2
1368:  MOVLP  10
1369:  CLRF   28
136A:  BTFSC  0B.7
136B:  BSF    28.7
136C:  BCF    0B.7
....................             delay_ms(10); 
136D:  MOVLW  0A
136E:  MOVLB  01
136F:  MOVWF  6C
1370:  MOVLP  00
1371:  MOVLB  00
1372:  CALL   04C
1373:  MOVLP  10
1374:  BTFSC  28.7
1375:  BSF    0B.7
....................             if (v[0]=='1') { 
1376:  MOVLB  01
1377:  MOVF   3B,W
1378:  SUBLW  31
1379:  BTFSS  03.2
137A:  GOTO   37D
....................             state = Ajustando; 
137B:  MOVLW  01
137C:  MOVWF  74
....................   
....................                         } 
....................             break;  
137D:  MOVLB  00
137E:  GOTO   7E6
....................            } 
....................              
....................             case Ajustando:  
....................              {  
....................              v[0]=g[0]; 
137F:  MOVF   73,W
1380:  MOVLB  01
1381:  MOVWF  3B
....................             lcd_gotoxy(1,1); 
1382:  MOVLW  01
1383:  MOVWF  51
1384:  MOVWF  52
1385:  MOVLP  00
1386:  MOVLB  00
1387:  CALL   2F0
1388:  MOVLP  10
....................             printf(lcd_putc,"\fFavor ingrese "); 
1389:  MOVLW  23
138A:  MOVLB  03
138B:  MOVWF  11
138C:  MOVLW  01
138D:  MOVWF  12
138E:  MOVLP  00
138F:  MOVLB  00
1390:  CALL   33A
1391:  MOVLP  10
1392:  CLRF   28
1393:  BTFSC  0B.7
1394:  BSF    28.7
1395:  BCF    0B.7
....................             delay_ms(100); 
1396:  MOVLW  64
1397:  MOVLB  01
1398:  MOVWF  6C
1399:  MOVLP  00
139A:  MOVLB  00
139B:  CALL   04C
139C:  MOVLP  10
139D:  BTFSC  28.7
139E:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
139F:  MOVLW  01
13A0:  MOVLB  01
13A1:  MOVWF  51
13A2:  MOVLW  02
13A3:  MOVWF  52
13A4:  MOVLP  00
13A5:  MOVLB  00
13A6:  CALL   2F0
13A7:  MOVLP  10
....................             printf(lcd_putc,"Tipo de control"); 
13A8:  MOVLW  2B
13A9:  MOVLB  03
13AA:  MOVWF  11
13AB:  MOVLW  01
13AC:  MOVWF  12
13AD:  MOVLP  00
13AE:  MOVLB  00
13AF:  CALL   33A
13B0:  MOVLP  10
....................             printf("Tipo de control?"); 
13B1:  MOVLW  33
13B2:  MOVLB  03
13B3:  MOVWF  11
13B4:  MOVLW  01
13B5:  MOVWF  12
13B6:  MOVLP  08
13B7:  MOVLB  00
13B8:  CALL   1D2
13B9:  MOVLP  10
13BA:  CLRF   28
13BB:  BTFSC  0B.7
13BC:  BSF    28.7
13BD:  BCF    0B.7
....................             delay_ms(100); 
13BE:  MOVLW  64
13BF:  MOVLB  01
13C0:  MOVWF  6C
13C1:  MOVLP  00
13C2:  MOVLB  00
13C3:  CALL   04C
13C4:  MOVLP  10
13C5:  BTFSC  28.7
13C6:  BSF    0B.7
....................             if (v[0]=='2') { 
13C7:  MOVLB  01
13C8:  MOVF   3B,W
13C9:  SUBLW  32
13CA:  BTFSS  03.2
13CB:  GOTO   3D0
....................             state = EleccionPI; 
13CC:  MOVLW  02
13CD:  MOVWF  74
....................             v[0]=0; 
13CE:  CLRF   3B
....................   
....................                         } 
13CF:  GOTO   3D6
....................             else if (v[0]=='3') { 
13D0:  MOVF   3B,W
13D1:  SUBLW  33
13D2:  BTFSS  03.2
13D3:  GOTO   3D6
....................             state = EleccionPID; 
13D4:  MOVLW  04
13D5:  MOVWF  74
....................   
....................                         } 
....................                          
....................             break; 
13D6:  MOVLB  00
13D7:  GOTO   7E6
....................              } 
....................               
....................              case EleccionPI:  
....................              {  
....................     //       nb=((10*v1[0])+v1[1]);  70 
....................       //     Set_point=nb; 
....................             if (nb>0) { 
13D8:  MOVF   70,F
13D9:  BTFSC  03.2
13DA:  GOTO   3DD
....................             state = cPI; 
13DB:  MOVLW  03
13DC:  MOVWF  74
....................   
....................           } 
....................               lcd_gotoxy(9,1); 
13DD:  MOVLW  09
13DE:  MOVLB  01
13DF:  MOVWF  51
13E0:  MOVLW  01
13E1:  MOVWF  52
13E2:  MOVLP  00
13E3:  MOVLB  00
13E4:  CALL   2F0
13E5:  MOVLP  10
....................             printf(lcd_putc,"\fControl PI "); 
13E6:  MOVLW  3C
13E7:  MOVLB  03
13E8:  MOVWF  11
13E9:  MOVLW  01
13EA:  MOVWF  12
13EB:  MOVLP  00
13EC:  MOVLB  00
13ED:  CALL   33A
13EE:  MOVLP  10
13EF:  CLRF   28
13F0:  BTFSC  0B.7
13F1:  BSF    28.7
13F2:  BCF    0B.7
....................             delay_ms(100); 
13F3:  MOVLW  64
13F4:  MOVLB  01
13F5:  MOVWF  6C
13F6:  MOVLP  00
13F7:  MOVLB  00
13F8:  CALL   04C
13F9:  MOVLP  10
13FA:  BTFSC  28.7
13FB:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
13FC:  MOVLW  01
13FD:  MOVLB  01
13FE:  MOVWF  51
13FF:  MOVLW  02
1400:  MOVWF  52
1401:  MOVLP  00
1402:  MOVLB  00
1403:  CALL   2F0
1404:  MOVLP  10
....................             printf(lcd_putc,"Ingrese Set Point"); 
1405:  MOVLW  43
1406:  MOVLB  03
1407:  MOVWF  11
1408:  MOVLW  01
1409:  MOVWF  12
140A:  MOVLP  00
140B:  MOVLB  00
140C:  CALL   33A
140D:  MOVLP  10
140E:  CLRF   28
140F:  BTFSC  0B.7
1410:  BSF    28.7
1411:  BCF    0B.7
....................             delay_ms(100); 
1412:  MOVLW  64
1413:  MOVLB  01
1414:  MOVWF  6C
1415:  MOVLP  00
1416:  MOVLB  00
1417:  CALL   04C
1418:  MOVLP  10
1419:  BTFSC  28.7
141A:  BSF    0B.7
....................             printf("Set Point?"); 
141B:  MOVLW  4C
141C:  MOVLB  03
141D:  MOVWF  11
141E:  MOVLW  01
141F:  MOVWF  12
1420:  MOVLP  08
1421:  MOVLB  00
1422:  CALL   1D2
1423:  MOVLP  10
....................              break; 
1424:  GOTO   7E6
....................               
....................              
....................              }   
....................               
....................               case cPI:  
....................              { v[0]=g[0]; 
1425:  MOVF   73,W
1426:  MOVLB  01
1427:  MOVWF  3B
....................           //    if(flag==1){ 
....................                   valor=read_adc(); 
1428:  BSF    1D.1
1429:  BTFSC  1D.1
142A:  GOTO   429
142B:  MOVF   1B,W
142C:  MOVWF  22
142D:  MOVF   1C,W
142E:  MOVWF  23
142F:  MOVLB  00
1430:  CLRF   28
1431:  BTFSC  0B.7
1432:  BSF    28.7
1433:  BCF    0B.7
....................                   delay_ms(30); 
1434:  MOVLW  1E
1435:  MOVLB  01
1436:  MOVWF  6C
1437:  MOVLP  00
1438:  MOVLB  00
1439:  CALL   04C
143A:  MOVLP  10
143B:  BTFSC  28.7
143C:  BSF    0B.7
....................           //               } 
....................            SPTU=set_point; 
143D:  MOVF   6F,W
143E:  MOVLB  01
143F:  MOVWF  3A
....................             temp1=calculos_rtd(valor); 
1440:  MOVF   23,W
1441:  MOVWF  3E
1442:  MOVF   22,W
1443:  MOVWF  3D
1444:  MOVLP  00
1445:  MOVLB  00
1446:  CALL   41E
1447:  MOVLP  10
1448:  MOVF   7A,W
1449:  MOVLB  01
144A:  MOVWF  2B
144B:  MOVF   79,W
144C:  MOVWF  2A
144D:  MOVF   78,W
144E:  MOVWF  29
144F:  MOVF   77,W
1450:  MOVWF  28
....................             Control=calculos_pi(temp1,Set_point); 
*
15C2:  MOVF   7A,W
15C3:  MOVWF  4C
15C4:  MOVF   79,W
15C5:  MOVWF  4B
15C6:  MOVF   78,W
15C7:  MOVWF  4A
15C8:  MOVF   77,W
15C9:  MOVWF  49
15CA:  MOVLP  00
15CB:  MOVLB  00
15CC:  CALL   6ED
15CD:  MOVLP  10
15CE:  MOVF   79,W
15CF:  MOVLB  01
15D0:  MOVWF  25
15D1:  MOVF   78,W
15D2:  MOVWF  24
....................             set_pwm1_duty(Control); 
15D3:  MOVF   25,W
15D4:  MOVWF  79
15D5:  MOVF   24,W
15D6:  MOVWF  78
15D7:  RLF    78,F
15D8:  RLF    79,F
15D9:  RLF    78,F
15DA:  RLF    79,F
15DB:  RLF    78,F
15DC:  RLF    79,F
15DD:  RLF    78,F
15DE:  RLF    79,F
15DF:  RLF    78,F
15E0:  RLF    79,F
15E1:  RLF    78,F
15E2:  RLF    79,F
15E3:  MOVF   79,W
15E4:  MOVLB  0C
15E5:  MOVWF  12
15E6:  MOVF   78,W
15E7:  MOVWF  11
....................             lcd_gotoxy(1,1);  
15E8:  MOVLW  01
15E9:  MOVLB  01
15EA:  MOVWF  51
15EB:  MOVWF  52
15EC:  MOVLP  00
15ED:  MOVLB  00
15EE:  CALL   2F0
15EF:  MOVLP  10
....................             printf(lcd_putc,"\fSetpoint V: %d",SPTU); 
15F0:  MOVLW  52
15F1:  MOVLB  03
15F2:  MOVWF  11
15F3:  MOVLW  01
15F4:  MOVWF  12
15F5:  BCF    03.0
15F6:  MOVLW  0D
15F7:  MOVLB  01
15F8:  MOVWF  3D
15F9:  MOVLP  00
15FA:  MOVLB  00
15FB:  CALL   70E
15FC:  MOVLP  10
15FD:  MOVLB  01
15FE:  MOVF   3A,W
15FF:  MOVWF  3D
1600:  MOVLW  18
1601:  MOVWF  3E
1602:  MOVLP  00
1603:  MOVLB  00
1604:  CALL   77D
1605:  MOVLP  10
1606:  CLRF   28
1607:  BTFSC  0B.7
1608:  BSF    28.7
1609:  BCF    0B.7
....................             delay_ms(10); 
160A:  MOVLW  0A
160B:  MOVLB  01
160C:  MOVWF  6C
160D:  MOVLP  00
160E:  MOVLB  00
160F:  CALL   04C
1610:  MOVLP  10
1611:  BTFSC  28.7
1612:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
1613:  MOVLW  01
1614:  MOVLB  01
1615:  MOVWF  51
1616:  MOVLW  02
1617:  MOVWF  52
1618:  MOVLP  00
1619:  MOVLB  00
161A:  CALL   2F0
161B:  MOVLP  10
....................             printf(lcd_putc,"D:%4lu T:%4.2f",control,temp1); 
161C:  MOVLW  44
161D:  MOVLB  01
161E:  MOVWF  50
161F:  MOVLP  00
1620:  MOVLB  00
1621:  CALL   304
1622:  MOVLP  10
1623:  MOVLW  3A
1624:  MOVLB  01
1625:  MOVWF  50
1626:  MOVLP  00
1627:  MOVLB  00
1628:  CALL   304
1629:  MOVLP  10
162A:  MOVLW  01
162B:  MOVWF  04
162C:  MOVLB  01
162D:  MOVF   25,W
162E:  MOVWF  3E
162F:  MOVF   24,W
1630:  MOVWF  3D
1631:  MOVLP  08
1632:  MOVLB  00
1633:  CALL   000
1634:  MOVLP  10
1635:  MOVLW  20
1636:  MOVLB  01
1637:  MOVWF  50
1638:  MOVLP  00
1639:  MOVLB  00
163A:  CALL   304
163B:  MOVLP  10
163C:  MOVLW  54
163D:  MOVLB  01
163E:  MOVWF  50
163F:  MOVLP  00
1640:  MOVLB  00
1641:  CALL   304
1642:  MOVLP  10
1643:  MOVLW  3A
1644:  MOVLB  01
1645:  MOVWF  50
1646:  MOVLP  00
1647:  MOVLB  00
1648:  CALL   304
1649:  MOVLP  10
164A:  MOVLW  03
164B:  MOVWF  04
164C:  MOVLB  01
164D:  MOVF   2B,W
164E:  MOVWF  40
164F:  MOVF   2A,W
1650:  MOVWF  3F
1651:  MOVF   29,W
1652:  MOVWF  3E
1653:  MOVF   28,W
1654:  MOVWF  3D
1655:  MOVLW  02
1656:  MOVWF  41
1657:  MOVLP  00
1658:  MOVLB  00
1659:  CALL   48B
165A:  MOVLP  10
165B:  CLRF   28
165C:  BTFSC  0B.7
165D:  BSF    28.7
165E:  BCF    0B.7
....................             delay_ms(40);  
165F:  MOVLW  28
1660:  MOVLB  01
1661:  MOVWF  6C
1662:  MOVLP  00
1663:  MOVLB  00
1664:  CALL   04C
1665:  MOVLP  10
1666:  BTFSC  28.7
1667:  BSF    0B.7
....................             envioUART(temp1); 
1668:  MOVLB  01
1669:  MOVF   2B,W
166A:  MOVWF  40
166B:  MOVF   2A,W
166C:  MOVWF  3F
166D:  MOVF   29,W
166E:  MOVWF  3E
166F:  MOVF   28,W
1670:  MOVWF  3D
1671:  MOVLP  08
1672:  MOVLB  00
1673:  CALL   156
1674:  MOVLP  10
....................             printf("Control PI"); 
1675:  MOVLW  5A
1676:  MOVLB  03
1677:  MOVWF  11
1678:  MOVLW  01
1679:  MOVWF  12
167A:  MOVLP  08
167B:  MOVLB  00
167C:  CALL   1D2
167D:  MOVLP  10
167E:  CLRF   28
167F:  BTFSC  0B.7
1680:  BSF    28.7
1681:  BCF    0B.7
....................             delay_ms(10); 
1682:  MOVLW  0A
1683:  MOVLB  01
1684:  MOVWF  6C
1685:  MOVLP  00
1686:  MOVLB  00
1687:  CALL   04C
1688:  MOVLP  10
1689:  BTFSC  28.7
168A:  BSF    0B.7
....................             if (v[0]=='1') { 
168B:  MOVLB  01
168C:  MOVF   3B,W
168D:  SUBLW  31
168E:  BTFSS  03.2
168F:  GOTO   692
....................             state = Ajustando; 
1690:  MOVLW  01
1691:  MOVWF  74
....................   
....................             } 
....................              break; 
1692:  MOVLB  00
1693:  GOTO   7E6
....................               
....................              
....................              }   
....................               
....................               case EleccionPID:  
....................              {  
....................              v[0]=g[0]; 
1694:  MOVF   73,W
1695:  MOVLB  01
1696:  MOVWF  3B
....................             lcd_gotoxy(1,1); 
1697:  MOVLW  01
1698:  MOVWF  51
1699:  MOVWF  52
169A:  MOVLP  00
169B:  MOVLB  00
169C:  CALL   2F0
169D:  MOVLP  10
....................             printf(lcd_putc,"\fControl PID "); 
169E:  MOVLW  60
169F:  MOVLB  03
16A0:  MOVWF  11
16A1:  MOVLW  01
16A2:  MOVWF  12
16A3:  MOVLP  00
16A4:  MOVLB  00
16A5:  CALL   33A
16A6:  MOVLP  10
16A7:  CLRF   28
16A8:  BTFSC  0B.7
16A9:  BSF    28.7
16AA:  BCF    0B.7
....................             delay_ms(10); 
16AB:  MOVLW  0A
16AC:  MOVLB  01
16AD:  MOVWF  6C
16AE:  MOVLP  00
16AF:  MOVLB  00
16B0:  CALL   04C
16B1:  MOVLP  10
16B2:  BTFSC  28.7
16B3:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
16B4:  MOVLW  01
16B5:  MOVLB  01
16B6:  MOVWF  51
16B7:  MOVLW  02
16B8:  MOVWF  52
16B9:  MOVLP  00
16BA:  MOVLB  00
16BB:  CALL   2F0
16BC:  MOVLP  10
....................             printf(lcd_putc,"Ingrese Set Point"); 
16BD:  MOVLW  67
16BE:  MOVLB  03
16BF:  MOVWF  11
16C0:  MOVLW  01
16C1:  MOVWF  12
16C2:  MOVLP  00
16C3:  MOVLB  00
16C4:  CALL   33A
16C5:  MOVLP  10
16C6:  CLRF   28
16C7:  BTFSC  0B.7
16C8:  BSF    28.7
16C9:  BCF    0B.7
....................             delay_ms(10); 
16CA:  MOVLW  0A
16CB:  MOVLB  01
16CC:  MOVWF  6C
16CD:  MOVLP  00
16CE:  MOVLB  00
16CF:  CALL   04C
16D0:  MOVLP  10
16D1:  BTFSC  28.7
16D2:  BSF    0B.7
....................             nb=v-48; 
16D3:  MOVLW  3B
16D4:  MOVWF  70
....................             Set_point=nb; 
16D5:  MOVF   70,W
16D6:  MOVWF  6F
....................             if (nb>4||nb<<100) { 
16D7:  MOVF   70,W
16D8:  SUBLW  04
16D9:  BTFSS  03.0
16DA:  GOTO   6DF
16DB:  MOVLW  00
16DC:  XORLW  00
16DD:  BTFSC  03.2
16DE:  GOTO   6E1
....................             state = cPID; 
16DF:  MOVLW  05
16E0:  MOVWF  74
....................           //  printf("Set Point?"); 
....................             } 
....................              break; 
16E1:  GOTO   7E6
....................               
....................              
....................              }   
....................               
....................            case cPID:  
....................              { v[0]=g[0]; 
16E2:  MOVF   73,W
16E3:  MOVLB  01
16E4:  MOVWF  3B
....................               if(flag==1){ 
16E5:  DECFSZ 72,W
16E6:  GOTO   6FD
....................             valor=read_adc(); 
16E7:  BSF    1D.1
16E8:  BTFSC  1D.1
16E9:  GOTO   6E8
16EA:  MOVF   1B,W
16EB:  MOVWF  22
16EC:  MOVF   1C,W
16ED:  MOVWF  23
16EE:  MOVLB  00
16EF:  CLRF   28
16F0:  BTFSC  0B.7
16F1:  BSF    28.7
16F2:  BCF    0B.7
....................             delay_ms(1); 
16F3:  MOVLW  01
16F4:  MOVLB  01
16F5:  MOVWF  6C
16F6:  MOVLP  00
16F7:  MOVLB  00
16F8:  CALL   04C
16F9:  MOVLP  10
16FA:  BTFSC  28.7
16FB:  BSF    0B.7
16FC:  MOVLB  01
....................           } 
....................             
....................            //  nb=((10*v1[0])+v1[1]); 
....................              //Set_point=nb; 
....................              temp1=calculos_rtd(valor); 
16FD:  MOVF   23,W
16FE:  MOVWF  3E
16FF:  MOVF   22,W
1700:  MOVWF  3D
1701:  MOVLP  00
1702:  MOVLB  00
1703:  CALL   41E
1704:  MOVLP  10
1705:  MOVF   7A,W
1706:  MOVLB  01
1707:  MOVWF  2B
1708:  MOVF   79,W
1709:  MOVWF  2A
170A:  MOVF   78,W
170B:  MOVWF  29
170C:  MOVF   77,W
170D:  MOVWF  28
....................              Controld=calculos_pid(temp1,Set_point); 
170E:  MOVF   2B,W
170F:  MOVWF  40
1710:  MOVF   2A,W
1711:  MOVWF  3F
1712:  MOVF   29,W
1713:  MOVWF  3E
1714:  MOVF   28,W
1715:  MOVWF  3D
1716:  MOVLB  00
1717:  MOVF   6F,W
1718:  MOVLB  01
1719:  MOVWF  41
171A:  MOVLP  08
171B:  MOVLB  00
171C:  GOTO   224
171D:  MOVLP  10
171E:  MOVF   7A,W
171F:  MOVLB  01
1720:  MOVWF  4C
1721:  MOVF   79,W
1722:  MOVWF  4B
1723:  MOVF   78,W
1724:  MOVWF  4A
1725:  MOVF   77,W
1726:  MOVWF  49
1727:  MOVLP  00
1728:  MOVLB  00
1729:  CALL   6ED
172A:  MOVLP  10
172B:  MOVF   79,W
172C:  MOVWF  6E
172D:  MOVF   78,W
172E:  MOVWF  6D
....................              set_pwm1_duty(Controld); 
172F:  MOVF   6E,W
1730:  MOVWF  79
1731:  MOVF   6D,W
1732:  MOVWF  78
1733:  RLF    78,F
1734:  RLF    79,F
1735:  RLF    78,F
1736:  RLF    79,F
1737:  RLF    78,F
1738:  RLF    79,F
1739:  RLF    78,F
173A:  RLF    79,F
173B:  RLF    78,F
173C:  RLF    79,F
173D:  RLF    78,F
173E:  RLF    79,F
173F:  MOVF   79,W
1740:  MOVLB  0C
1741:  MOVWF  12
1742:  MOVF   78,W
1743:  MOVWF  11
....................             lcd_gotoxy(1,1);  
1744:  MOVLW  01
1745:  MOVLB  01
1746:  MOVWF  51
1747:  MOVWF  52
1748:  MOVLP  00
1749:  MOVLB  00
174A:  CALL   2F0
174B:  MOVLP  10
....................             printf(lcd_putc,"\fSetpoint V %d",Set_point); 
174C:  MOVLW  70
174D:  MOVLB  03
174E:  MOVWF  11
174F:  MOVLW  01
1750:  MOVWF  12
1751:  BCF    03.0
1752:  MOVLW  0C
1753:  MOVLB  01
1754:  MOVWF  3D
1755:  MOVLP  00
1756:  MOVLB  00
1757:  CALL   70E
1758:  MOVLP  10
1759:  MOVF   6F,W
175A:  MOVLB  01
175B:  MOVWF  3D
175C:  MOVLW  18
175D:  MOVWF  3E
175E:  MOVLP  00
175F:  MOVLB  00
1760:  CALL   77D
1761:  MOVLP  10
1762:  CLRF   28
1763:  BTFSC  0B.7
1764:  BSF    28.7
1765:  BCF    0B.7
....................             delay_ms(100); 
1766:  MOVLW  64
1767:  MOVLB  01
1768:  MOVWF  6C
1769:  MOVLP  00
176A:  MOVLB  00
176B:  CALL   04C
176C:  MOVLP  10
176D:  BTFSC  28.7
176E:  BSF    0B.7
....................             lcd_gotoxy(1,2); 
176F:  MOVLW  01
1770:  MOVLB  01
1771:  MOVWF  51
1772:  MOVLW  02
1773:  MOVWF  52
1774:  MOVLP  00
1775:  MOVLB  00
1776:  CALL   2F0
1777:  MOVLP  10
....................             printf(lcd_putc,"D%4.2f",ukt); 
1778:  MOVLW  44
1779:  MOVLB  01
177A:  MOVWF  50
177B:  MOVLP  00
177C:  MOVLB  00
177D:  CALL   304
177E:  MOVLP  10
177F:  MOVLW  03
1780:  MOVWF  04
1781:  MOVF   48,W
1782:  MOVLB  01
1783:  MOVWF  40
1784:  MOVLB  00
1785:  MOVF   47,W
1786:  MOVLB  01
1787:  MOVWF  3F
1788:  MOVLB  00
1789:  MOVF   46,W
178A:  MOVLB  01
178B:  MOVWF  3E
178C:  MOVLB  00
178D:  MOVF   45,W
178E:  MOVLB  01
178F:  MOVWF  3D
1790:  MOVLW  02
1791:  MOVWF  41
1792:  MOVLP  00
1793:  MOVLB  00
1794:  CALL   48B
1795:  MOVLP  10
....................             lcd_gotoxy(10,2); 
1796:  MOVLW  0A
1797:  MOVLB  01
1798:  MOVWF  51
1799:  MOVLW  02
179A:  MOVWF  52
179B:  MOVLP  00
179C:  MOVLB  00
179D:  CALL   2F0
179E:  MOVLP  10
....................             printf(lcd_putc,"T%4.2f",temp1); 
179F:  MOVLW  54
17A0:  MOVLB  01
17A1:  MOVWF  50
17A2:  MOVLP  00
17A3:  MOVLB  00
17A4:  CALL   304
17A5:  MOVLP  10
17A6:  MOVLW  03
17A7:  MOVWF  04
17A8:  MOVLB  01
17A9:  MOVF   2B,W
17AA:  MOVWF  40
17AB:  MOVF   2A,W
17AC:  MOVWF  3F
17AD:  MOVF   29,W
17AE:  MOVWF  3E
17AF:  MOVF   28,W
17B0:  MOVWF  3D
17B1:  MOVLW  02
17B2:  MOVWF  41
17B3:  MOVLP  00
17B4:  MOVLB  00
17B5:  CALL   48B
17B6:  MOVLP  10
17B7:  CLRF   28
17B8:  BTFSC  0B.7
17B9:  BSF    28.7
17BA:  BCF    0B.7
....................             delay_ms(40);  
17BB:  MOVLW  28
17BC:  MOVLB  01
17BD:  MOVWF  6C
17BE:  MOVLP  00
17BF:  MOVLB  00
17C0:  CALL   04C
17C1:  MOVLP  10
17C2:  BTFSC  28.7
17C3:  BSF    0B.7
....................             envioUART(temp1); 
17C4:  MOVLB  01
17C5:  MOVF   2B,W
17C6:  MOVWF  40
17C7:  MOVF   2A,W
17C8:  MOVWF  3F
17C9:  MOVF   29,W
17CA:  MOVWF  3E
17CB:  MOVF   28,W
17CC:  MOVWF  3D
17CD:  MOVLP  08
17CE:  MOVLB  00
17CF:  CALL   156
17D0:  MOVLP  10
17D1:  CLRF   28
17D2:  BTFSC  0B.7
17D3:  BSF    28.7
17D4:  BCF    0B.7
....................            // printf("Control PID"); 
....................             delay_ms(10); 
17D5:  MOVLW  0A
17D6:  MOVLB  01
17D7:  MOVWF  6C
17D8:  MOVLP  00
17D9:  MOVLB  00
17DA:  CALL   04C
17DB:  MOVLP  10
17DC:  BTFSC  28.7
17DD:  BSF    0B.7
....................             if (v[0]=='1') { 
17DE:  MOVLB  01
17DF:  MOVF   3B,W
17E0:  SUBLW  31
17E1:  BTFSS  03.2
17E2:  GOTO   7E5
....................             state = Ajustando; 
17E3:  MOVLW  01
17E4:  MOVWF  74
....................   
....................             } 
....................              break; 
17E5:  MOVLB  00
....................                           
....................              }                     
....................           }//end Switch 
17E6:  GOTO   0F9
....................  
.................... } 
.................... } 
17E7:  SLEEP

Configuration Fuses:
   Word  1: 39E4   INTRC_IO NOWDT NOPUT MCLR NOPROTECT NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1ECF   NOWRT NOCPUDIV LS48MHZ PLL3X NOPLLEN STVREN BORV19 NOLPBOR NODEBUG NOLVP
